<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>INQUIRY AGENT (git)</title>
<link rel="icon" href="data:,">
<link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#0a0f1e; --panel:#0f172a; --ink:#e8eef7; --muted:#94a3b8; --stroke:#1e293b;
    --brand1:#22d3ee; --brand2:#a78bfa; --ok:#34d399; --warn:#fbbf24;
    --p-blue:#e8f3ff; --p-blue-b:#93c5fd;
    --p-red:#ffe7ea; --p-red-b:#fda4af;
    --p-green:#ecfff4; --p-green-b:#86efac;
    --p-purple:#f3e8ff; --p-purple-b:#c4b5fd;
    --p-yellow:#fef3c7; --p-yellow-b:#f59e0b;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 900px at 10% 0%, #0d1634, #0a0f1e 60%);color:var(--ink);font-family:'Lexend',system-ui,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;min-height:100vh;min-width:100vw}
  
  /* Fullscreen viewport handling */
  #app {
    position: fixed;
    inset: 0;
    width: 100vw;
    height: 100dvh;
    overflow: hidden;
    touch-action: none;
  }
  
  /* Use small viewport height for better browser compatibility */
  @supports (height: 100svh) {
    #app {
      height: 100svh;
    }
  }
  *{user-select:none} input,textarea,select,button{user-select:text}

  .app{display:grid;grid-template-rows:auto auto 1fr auto;gap:0;height:100vh;padding:12px;box-sizing:border-box;min-height:100vh;overflow:visible;max-height:100vh}
  
  /* Use small viewport height for better browser compatibility */
  @supports (height: 100svh) {
    .app {
      height: 100svh;
      min-height: 100svh;
      max-height: 100svh;
    }
  }

/* SMART Board optimization - only apply 16:9 when screen is very wide (like 4K displays) */
@media screen and (min-width: 3000px) {
  .app {
    aspect-ratio: 16/9;
    width: 100vw;
    max-height: 90vh; /* Reduced to account for SMART Board toolbar */
    overflow: visible;
    padding: 8px; /* Reduced padding to save space */
  }
  
  /* Ensure bottom row is always visible on SMART Board */
  .stepsRow {
    position: sticky;
    bottom: 0;
    margin-top: 4px;
    height: 44px;
    padding: 6px 10px;
  }
}

  /* Top bar: 3 columns (stats | timer | actions) */
  .topbar{display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;min-height:48px}
  .stats{display:flex;gap:8px;flex-wrap:wrap}
  .stat{background:#0b1226;border:1px solid var(--stroke);border-radius:12px;padding:6px 10px;font-weight:700}

  .actions{display:flex;gap:10px;align-items:center;justify-content:flex-end}
  .topbtn{background:#0b1226;border:1px solid var(--stroke);color:var(--ink);padding:10px 14px;border-radius:14px;font-weight:900;font-size:16px;cursor:pointer;box-shadow:0 10px 20px rgba(0,0,0,.35);transition:.12s transform,.12s box-shadow;height:42px;display:inline-flex;align-items:center;touch-action:manipulation;min-height:44px}
  .topbtn:active{transform:translateY(1px) scale(.98);box-shadow:0 6px 12px rgba(0,0,0,.35)}
  #randomBtn{background:radial-gradient(120% 120% at 10% 0%, var(--brand2), var(--brand1));color:#06121a;border:none;touch-action:manipulation}
  
  /* Enhanced touch support for critical action buttons */
  #genBtn, #quickReset, #openSettings {
    touch-action: manipulation;
    min-height: 44px;
  }
  
  #genBtn:active, #quickReset:active, #openSettings:active {
    transform: scale(0.98);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  
  /* Enhanced touch support for read button on SMART Boards */
  #readAloudBtn {
    touch-action: manipulation;
    -webkit-tap-highlight-color: transparent;
    min-width: 44px;
    min-height: 44px;
  }
  
  #readAloudBtn:active {
    transform: scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  
  /* Enhanced touch support for inquiry agent logo */
  #inquiryAgentLogo {
    touch-action: manipulation;
    min-width: 40px;
    min-height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  #inquiryAgentLogo:active {
    transform: translateY(-50%) scale(0.95) !important;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }

  /* Timer (center) */
  .timerWrap{display:flex;align-items:center;justify-content:center;gap:8px}
  .timerBox{display:flex;align-items:center;gap:8px;background:#0b1226;border:1px solid var(--stroke);border-radius:12px;padding:6px 10px}
  .time{font-weight:900;font-size:20px;min-width:70px;text-align:center}
  .tbtn{background:#0c1428;border:1px solid #1f2937;color:#dbeafe;border-radius:10px;padding:8px 12px;font-weight:800;cursor:pointer;touch-action:manipulation;min-width:44px;min-height:44px}
    .tbtn:active{transform:translateY(1px) scale(0.98);box-shadow:inset 0 2px 4px rgba(0,0,0,0.3)}
  
  /* Enhanced touch support for small group size buttons */
  #decreaseGroupSize, #increaseGroupSize {
    touch-action: manipulation;
    min-width: 44px;
    min-height: 44px;
    padding: 8px 12px !important;
  }
  
  #decreaseGroupSize:active, #increaseGroupSize:active {
    transform: scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }
  
  /* Question */
  .questionRow{display:flex;justify-content:center;align-items:stretch;gap:20px;position:relative;z-index:60;height:fit-content;min-height:auto}
  .question{
    text-align:center;font-size:clamp(36px,7vw,80px);font-weight:900;letter-spacing:.2px;
    padding:10px 14px;background:rgba(15,23,42,.6);border:1px solid var(--stroke);border-radius:14px;
    width:min(1200px,100%);min-height:2.8em;white-space:normal;flex-shrink:0;line-height:1.2;max-height:2.4em;overflow:hidden;margin-top:0;
  }
  .question-helper{
    background:rgba(15,23,42,.6);border:1px solid var(--stroke);border-radius:10px;
    display:flex;flex-direction:column;cursor:pointer;transition:all .2s;position:relative;flex:1;z-index:1;margin-top:0;pointer-events:none;align-self:stretch;
  }
  .question-helper:hover{
    background:rgba(15,23,42,.8);border-color:#475569;
  }
  .helper-title{
    padding:8px 12px;font-size:11px;font-weight:700;color:#94a3b8;text-align:center;border-bottom:1px solid var(--stroke);position:absolute;top:0;left:0;right:0;z-index:1;background:rgba(15,23,42,.9);margin:0;border-radius:10px 10px 0 0;pointer-events:none;
  }
  .helper-content{
    flex:1;padding:8px;position:relative;margin-top:40px;pointer-events:none;
  }

  /* Stage */
  .stage{position:relative;display:flex;flex-direction:column;gap:0;min-height:0;flex:1;width:100%}

/* SMART Board optimization - only apply 16:9 when screen is very wide */
@media screen and (min-width: 3000px) {
  .stage {
    aspect-ratio: 16/9;
    max-height: calc(100vh - 250px); /* Increased space for bottom row */
  }
}
  #badgeLayer{position:absolute;inset:0;z-index:5000;pointer-events:none}
  #badgeLayer .badge{pointer-events:auto}

  .zones{display:grid;gap:10px;grid-auto-rows:minmax(180px,1fr);flex:1;min-height:0}
  .zone{position:relative;border-radius:18px;border:2px dashed #94a3b8;padding:10px;box-shadow:0 12px 36px rgba(0,0,0,.18) inset}
  .zone h3{margin:0 0 6px 0;font-size:clamp(16px,2vw,24px);font-weight:900;color:#0b1020;text-shadow:0 1px 0 rgba(255,255,255,.7)}
  .blue{background:var(--p-blue);border-color:var(--p-blue-b)}
  .red{background:var(--p-red);border-color:var(--p-red-b)}
  .green{background:var(--p-green);border-color:var(--p-green-b)}
  .purple{background:var(--p-purple);border-color:var(--p-purple-b)}
  .yellow{background:var(--p-yellow);border-color:var(--p-yellow-b)}

  /* Parking */
  .parking{background:#0b1226;border-radius:16px;border:1px solid var(--stroke);padding:10px;min-height:210px;position:relative;flex-shrink:0}
  #parkingPad{position:absolute;inset:8px;border:2px dashed #1f2937;border-radius:12px;min-height:230px}
  #parkingLabel{position:absolute;top:14px;left:16px;background:rgba(2,6,23,.8);border:1px solid #1f2937;color:#cbd5e1;padding:6px 10px;border-radius:10px;font-weight:900;font-size:14px;box-shadow:0 8px 18px rgba(0,0,0,.35)}

  /* Steps row */
  .stepsRow{display:flex;align-items:center;justify-content:center;gap:8px;padding:6px 12px;height:40px;background:#0b1226;border:1px solid var(--stroke);border-radius:12px;white-space:nowrap;flex-shrink:0;margin-top:8px;box-shadow:0 4px 12px rgba(0,0,0,.3);position:relative;z-index:100;min-height:40px;max-height:40px;overflow:visible}

/* Ensure steps row is always visible on all screen sizes */
@media screen and (max-height: 800px) {
  .stepsRow {
    height: 40px;
    padding: 6px 10px;
    margin-top: 4px;
  }
}

/* SMART Board MX065-V4 (3840√ó2160) and similar 4K displays */
@media screen and (min-width: 3800px) and (min-height: 2000px) {
  .app {
    max-height: 85vh; /* Leave more space for SMART Board browser interface */
    height: 85vh; /* Force height to ensure bottom bar is visible */
  }
  
  .stage {
    max-height: calc(85vh - 200px); /* Ensure stage doesn't push bottom row off screen */
  }
  
  .stepsRow {
    position: sticky;
    bottom: 0;
    background: #0b1226;
    border-top: 2px solid var(--stroke);
    z-index: 1000;
    pointer-events: none; /* Allow touches to pass through to badges behind */
    min-height: 50px; /* Ensure adequate height */
  }
  
  .stepsRow > * {
    pointer-events: auto; /* Re-enable pointer events for child elements */
  }
}

/* Extra protection for very wide screens (SMART Boards) */
@media screen and (min-width: 3000px) and (min-height: 1000px) and (max-width: 3799px) {
  .app {
    max-height: 90vh; /* Leave more space for SMART Board toolbars */
  }
  
  .stage {
    max-height: calc(90vh - 250px); /* Ensure stage doesn't push bottom row off screen */
  }
  
  .stepsRow {
    position: sticky;
    bottom: 0;
    background: #0b1226;
    border-top: 2px solid var(--stroke);
    z-index: 1000;
    pointer-events: none; /* Allow touches to pass through to badges behind */
  }
  
  .stepsRow > * {
    pointer-events: auto; /* Re-enable pointer events for child elements */
  }
}
  .stepPill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;font-weight:900;font-size:14px;background:#0f172a;border:1px solid #1f2937}
  .stepSep{opacity:.7}

  /* Badges */
  .badge{position:absolute;touch-action:none;display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:999px;font-weight:800;font-size:clamp(14px,1.8vw,20px);color:#0b1226;background:linear-gradient(180deg,#f8fafc,#e2e8f0);box-shadow:0 10px 22px rgba(0,0,0,.35);border:2px solid #0f172a;transition:top .25s cubic-bezier(.34,1.56,.64,1), left .25s cubic-bezier(.34,1.56,.64,1);z-index:5000}
  .badge.inParking:not(.teacher){background:linear-gradient(180deg,#fff1e6,#ffd7b5);border-color:#9a6a3a}
  .badge.teacher{background:linear-gradient(180deg,#fff7d6,#fde68a);border-color:#b45309}
  .badge[data-zone="partner"], .badge[data-zone="help"]{background:linear-gradient(180deg,#fee2e2,#fecaca);border-color:#dc2626}
  .badge.pickedHidden{opacity:0;pointer-events:none;transition:opacity .2s}
  .badge.spinning{outline:4px solid var(--warn)}
  .badge.winner{outline:6px solid var(--ok)}
  
  /* Remove browser arrows from number input */
  #partnerSize::-webkit-outer-spin-button,
  #partnerSize::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  #partnerSize {
    -moz-appearance: textfield;
  }

  /* Modals */
  .modal{position:fixed;inset:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:100}
  .modal.show{display:flex}
  .sheet{width:min(1100px,95vw);max-height:90vh;overflow:auto;background:#0b1226;border:1px solid var(--stroke);border-radius:18px;padding:18px;box-shadow:0 22px 64px rgba(0,0,0,.5);color:var(--ink)}
  
  /* Roster modal should be above settings modal */
  #rosterModal{z-index:1000}
  .sheet h2{margin:0 0 10px}
  .sheet section{border:1px solid #1f2937;border-radius:14px;padding:12px;margin:10px 0;background:#0c1428}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  .pair{display:flex;align-items:center;gap:8px;margin-right:16px}
  .sheet input,.sheet select,.sheet textarea,.sheet button{font-size:16px;border-radius:12px;border:1px solid #334155;background:#0b1226;color:var(--ink);padding:10px 12px}
  .sheet button{box-shadow:0 8px 18px rgba(0,0,0,.35);touch-action:manipulation;min-height:44px}
  .sheet button:active{transform:translateY(1px) scale(.98);box-shadow:0 6px 12px rgba(0,0,0,.35)}
  .answers-grid{display:grid;gap:8px;grid-template-columns:repeat(2,minmax(0,1fr))}
  .answers-grid .a{display:flex;gap:8px;align-items:center}
  .answers-grid .lbl{width:130px;font-weight:800;text-align:right;opacity:.9}
  .answers-grid input{flex:1}

  .btn-primary{background:linear-gradient(180deg,#34d399,#22c55e);color:#05220f;border:1px solid #166b3b;touch-action:manipulation}
  .btn-ghost{background:#0b1226;border:1px solid #1f2937;color:#d1d5db;touch-action:manipulation}
  
  /* Enhanced touch support for AI model buttons */
  .model-btn {
    touch-action: manipulation;
    min-width: 48px;
    min-height: 44px;
    padding: 6px 10px !important;
  }
  
  .model-btn:active {
    transform: scale(0.95);
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
  }

  .switch{position:relative;width:56px;height:30px;background:#0c1428;border:1px solid #1f2937;border-radius:999px;cursor:pointer;touch-action:manipulation;min-height:44px}
  .switch input{display:none}
  .knob{position:absolute;top:3px;left:3px;width:24px;height:24px;background:#cbd5e1;border-radius:50%;transition:left .18s}
  .switch input:checked + .knob{left:29px;background:#34d399}

  .toast{position:fixed;bottom:16px;left:16px;background:#0b1226;color:var(--ink);border:1px solid var(--stroke);border-radius:12px;padding:10px 14px;opacity:0;transform:translateY(8px);transition:.25s;z-index:10001}
  .toast.show{opacity:1;transform:translateY(0)}
  #qDebug{position:fixed;right:10px;bottom:10px;background:#0b1226;border:1px solid #1f2937;border-radius:10px;padding:8px 10px;font:12px/1.2 Lexend;color:#cbd5e1;opacity:.85;z-index:130;display:none}

  /* Response buttons */
  .response-buttons{display:flex;gap:8px}
  .response-btn{background:#0c1428;border:1px solid #1f2937;color:#dbeafe;border-radius:10px;padding:10px 18px;font-weight:800;cursor:pointer;transition:all .2s;touch-action:manipulation;min-width:48px;min-height:44px}
  .response-btn:hover{background:#0f172a;border-color:#334155}
  .response-btn.active{background:linear-gradient(180deg,#34d399,#22c55e);color:#05220f;border-color:#166b3b}

  /* Preset buttons */
  .preset-btn{background:#0f172a;border:1px solid #334155;color:#94a3b8;border-radius:10px;padding:10px 18px;font-weight:800;cursor:pointer;transition:all .2s;touch-action:manipulation;min-width:48px;min-height:44px}
  .preset-btn:hover{background:#1e293b;border-color:#475569;color:#cbd5e1}

  #settingsModal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;justify-content:center;align-items:center;z-index:99999}
  #settingsModal.show{display:flex}

  #aiModal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.8);display:none;justify-content:center;align-items:center;z-index:9999999}
  
  /* Winner modal should be above badges but below settings */
  #winnerModal{z-index:10002}
  #aiModal.show{display:flex}
  
  /* Highlight word styling - prevents size changes during text-to-speech */
  .highlight-word {
    padding: 0 !important;
    margin: 0 !important;
    display: inline !important;
    font-size: inherit !important;
    line-height: inherit !important;
    vertical-align: baseline !important;
    box-sizing: border-box !important;
  }
</style>
</head>
<body>



<div class="app" id="app">
  <div class="topbar">
    <div class="stats">
      <span id="aiStatus" style="cursor: pointer; font-weight: bold; display: none;" onclick="openAISettings()">‚ùå</span>
      <span id="placedCount">Placed: 0</span>
      <span id="absentCount">Absent (not placed): 20</span>
      <div class="partner-input" style="display: inline-flex; align-items: center; gap: 8px; margin-left: 60px;">
        <button class="tbtn" id="decreaseGroupSize" style="padding: 4px 8px;">‚ñº</button>
        <input id="partnerSize" type="number" min="2" max="10" value="2" style="width: 40px; background: #0b1226; border: 1px solid var(--stroke); color: var(--ink); border-radius: 8px; padding: 4px 6px; font-size: 14px; font-weight: 700; text-align: center; -webkit-appearance: none !important; -moz-appearance: textfield !important; appearance: none !important;" onkeypress="return event.charCode >= 48 && event.charCode <= 57">
        <button class="tbtn" id="increaseGroupSize" style="padding: 4px 8px;">‚ñ≤</button>
        <button id="partnerBtn" class="topbtn" style="padding: 6px 10px; font-size: 14px;">üë•</button>
      </div>
    </div>

    <!-- Center timer -->
    <div class="timerWrap">
      <div class="timerBox">
        <button class="tbtn" id="tReset">‚Üª</button>
        <button class="tbtn" id="minus30">‚àí</button>
        <div class="time" id="timeText">1:00</div>
        <button class="tbtn" id="plus30">+</button>
        <button class="tbtn" id="startPause">‚ñ∂</button>
      </div>
    </div>

    <div class="actions">
      <button class="topbtn" id="openSettings">‚öôÔ∏è Settings</button>
      <button class="topbtn" id="quickReset">Reset</button>
      <button class="topbtn" id="readAloudBtn">üó£Ô∏è</button>
      <button class="topbtn" id="randomBtn">üé° Random Student</button>
      <button class="topbtn" id="fullscreenBtn">[ ]</button>
    </div>
  </div>

  <div class="questionRow">
    <div class="question-helper" id="partnerArea">
      <div class="helper-title">üîé Partner</div>
      <div class="helper-content"></div>
    </div>
    <div class="question" id="question">Loading question‚Ä¶</div>
    <div class="question-helper" id="helpArea">
      <div class="helper-title">üìñ Help</div>
      <div class="helper-content"></div>
    </div>
  </div>
  <!-- Hidden live region for enforced paint/AT -->
  <div aria-live="polite" aria-atomic="true" style="position:absolute;left:-9999px;top:auto;width:1px;height:1px;overflow:hidden" id="qLive">Loading question‚Ä¶</div>

  <div class="stage" id="stage">
    <div class="zones" id="zones"></div>
    <div class="parking" id="parking"><div id="parkingPad"></div><div id="parkingLabel">üÖøÔ∏è Parking Lot / Absent</div></div>
    <div class="stepsRow" style="position: relative;">
      <div id="inquiryAgentLogo" style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%); font-family: 'Arial Black', 'Helvetica Bold', sans-serif; font-weight: 900; font-size: 16px; color: #00d4ff; text-shadow: 0 0 10px #00d4ff, 0 0 20px #00d4ff; cursor: pointer; user-select: none; transition: all 0.3s ease; padding: 6px 10px; border-radius: 6px; background: linear-gradient(135deg, rgba(0,212,255,0.1) 0%, rgba(0,212,255,0.05) 100%); border: 1px solid rgba(0,212,255,0.3); z-index: 5; line-height: 1;" title="Click for app info" onmouseover="this.style.transform='translateY(-50%) scale(1.05)'; this.style.textShadow='0 0 15px #00d4ff, 0 0 25px #00d4ff, 0 0 35px #00d4ff';" onmouseout="this.style.transform='translateY(-50%) scale(1)'; this.style.textShadow='0 0 10px #00d4ff, 0 0 20px #00d4ff';">INQUIRY AGENT</div>
      
      <!-- Centered steps container -->
      <div style="display: flex; justify-content: center; align-items: center; width: 100%;">
        <div class="stepPill">üìñ READ</div><span class="stepSep">‚Ä∫</span>
        <div class="stepPill">ü§î THINK</div><span class="stepSep">‚Ä∫</span>
        <div class="stepPill">üë• DISCUSS</div><span class="stepSep">‚Ä∫</span>
        <div class="stepPill">‚û°Ô∏è MOVE</div><span class="stepSep">‚Ä∫</span>
        <div class="stepPill">üó£Ô∏è EXPLAIN</div>
      </div>
      
      <!-- Question source indicators - positioned on the right side -->
      <div id="manualIndicator" style="position: absolute; right: 70px; top: 50%; transform: translateY(-50%); background: #4CAF50; color: white; border-radius: 50%; width: 24px; height: 24px; display: none; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; z-index: 10; opacity: 0.9; border: 2px solid #0a0f1e;">M</div>
      <div id="aiIndicator" style="position: absolute; right: 10px; top: 50%; transform: translateY(-50%); background: white; color: #0a0f1e; border-radius: 50%; width: 24px; height: 24px; display: none; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; z-index: 10; opacity: 0.9; border: 2px solid #0a0f1e;">A</div>
      <div id="bankIndicator" style="position: absolute; right: 40px; top: 50%; transform: translateY(-50%); background: #6b7280; color: white; border-radius: 50%; width: 24px; height: 24px; display: none; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; z-index: 10; opacity: 0.8; border: 2px solid #0a0f1e;">B</div>
    </div>
    <div id="badgeLayer"></div>
  </div>
</div>

<!-- Settings modal -->
<div class="modal" id="settingsModal"><div class="sheet">
  <h2>‚öôÔ∏è Settings</h2>

  <!-- 1. Question, Responses & Answer Fields -->
  <section>
    <div class="row">
      <label style="min-width:110px;font-weight:800">Question</label>
      <input id="qInput" placeholder="Daily question (or generate with AI)" style="flex:1"/>
    </div>
    
    <div class="row" style="gap:16px;margin-top:12px">
      <div class="pair">
        <label style="min-width:110px;font-weight:800">Responses</label>
        <div class="response-buttons">
          <button class="response-btn" data-value="2">2</button>
          <button class="response-btn" data-value="3">3</button>
          <button class="response-btn active" data-value="4">4</button>
          <button class="response-btn" data-value="open">Open</button>
          <button class="response-btn" data-value="wyr">Would You Rather?</button>
        </div>
      </div>
    </div>
    
    <div id="answersWrap" style="margin-top:12px">
      <div class="answers-grid">
        <div class="a"><div class="lbl">Answer A</div><input id="a1" value="Work alone"></div>
        <div class="a"><div class="lbl">Answer B</div><input id="a2" value="Work with a partner"></div>
        <div class="a"><div class="lbl">Answer C</div><input id="a3" value="Ask a teacher"></div>
        <div class="a"><div class="lbl">Answer D</div><input id="a4" value="Try a new strategy"></div>
      </div>
    </div>
  </section>

  <!-- Filters + AI -->
  <section>
    <div class="row" style="margin-top:4px">
      <label style="font-weight:800">Keywords</label>
      <input id="keywordInput" placeholder="e.g., patterns, habitats, friendship" style="flex:1;min-width:260px"/>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="pair">
        <label style="font-weight:800">Grade</label>
        <select id="gradeInput"><option selected>-</option><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option></select>
      </div>
      <div class="pair">
        <label style="font-weight:800">Concise</label>
        <label class="switch" title="Shorten questions and responses">
          <input type="checkbox" id="conciseToggle">
          <span class="knob"></span>
        </label>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="pair"><label style="font-weight:800">Bloom's</label>
        <select id="bloomsInput">
          <option selected>-</option><option>Remember</option><option>Understand</option><option>Apply</option><option>Analyze</option>
          <option>Evaluate</option><option>Create</option>
        </select>
      </div>
      <div class="pair"><label style="font-weight:800">Subject</label>
        <select id="subjectInput">
          <option selected>-</option><option>Math</option><option>Language</option><option>Science</option>
          <option>Social Studies</option><option>Drama</option><option>Dance</option>
          <option>Visual Arts</option><option>Music</option><option>Phys-Ed</option>
        </select>
      </div>
      <div class="pair"><label style="font-weight:800">Learning Skill</label>
        <select id="lsInput">
          <option selected>-</option>
          <option>Responsibility</option><option>Organization</option><option>Independent Work</option>
          <option>Collaboration</option><option>Initiative</option><option>Self-Regulation</option>
        </select>
      </div>
      <div class="pair"><label style="font-weight:800">SEL</label>
        <select id="selInput">
          <option selected>-</option>
          <!-- options injected by JS from SEL_TOPICS -->
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:16px">
      <button id="genBtn">‚ú® Generate with AI</button>
      <button id="aiBtn">ü§ñ AI Settings</button>
      <span id="aiStatusMain" style="font-weight:700;color:#94a3b8">AI: not checked</span>
      <button id="resetFiltersBtn" style="margin-left:auto">üîÑ Reset Filters</button>
    </div>

  </section>

  <!-- Preset buttons row -->
  <section>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <button id="presetMood" class="preset-btn">üü¶üü•üü®üü© Mood Checker</button>
      <button id="presetWeekend" class="preset-btn">üå§Ô∏è Weekend Reflection</button>
      <button id="presetLeo" class="preset-btn">ü¶Å Leo's Ceremony</button>
    </div>
  </section>

  <!-- Tools row -->
  <section>
    <div class="row" style="gap:12px;flex-wrap:wrap">
      <button id="openRoster">üë• Edit Roster</button>
      <button id="saveBtn">üíæ Save Layout</button>
      <button id="loadBtn">‚≠≥ Load Layout</button>
      <button id="resetWeekBtn">üóìÔ∏è Reset Week</button>
      <button id="resetQuestionsBtn" style="background: #dc2626; color: white; border-color: #dc2626;">üîÑ Reset Questions</button>
    </div>
  </section>

  <div class="row" style="justify-content:center;margin-top:16px;gap:20px">
    <button id="applySettings" class="btn-primary" style="font-weight:900;padding:14px 24px;font-size:18px">‚úÖ OK</button>
    <button id="closeSettings" class="btn-ghost" style="padding:14px 24px;font-size:18px">Cancel</button>
  </div>
</div></div>

<!-- Info Dialog Modal -->
<div class="modal" id="infoModal"><div class="sheet">
  <h2 style="text-align: center; color: #00d4ff; text-shadow: 0 0 10px #00d4ff;">üöÄ INQUIRY AGENT</h2>
  <p style="text-align: center; font-style: italic; color: #666; margin-bottom: 20px;">Designed by Tony Cushman (2025)</p>
  
  <div style="margin-bottom: 20px;">
    <h3 style="color: #333; border-bottom: 2px solid #00d4ff; padding-bottom: 5px;">üéØ How to Use</h3>
    <p><strong>1.</strong> Use the <strong>Generate with AI</strong> button to create questions based on your filters</p>
    <p><strong>2.</strong> Students move their names into response zones based on their answers</p>
    <p><strong>3.</strong> Use the <strong>Random Pick</strong> button to select students to explain their thinking</p>
    <p><strong>4.</strong> Students can be moved to partner areas or help zones as needed</p>
  </div>
  
  <div style="margin-bottom: 20px;">
    <h3 style="color: #333; border-bottom: 2px solid #00d4ff; padding-bottom: 5px;">‚å®Ô∏è Hotkeys</h3>
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
      <div><strong>R</strong> - Reset all students to parking</div>
      <div><strong>G</strong> - Generate new question</div>
      <div><strong>S</strong> - Open settings</div>
      <div><strong>A</strong> - Open AI settings</div>
      <div><strong>1-4</strong> - Set response mode</div>
      <div><strong>W</strong> - Would you rather mode</div>
      <div><strong>T</strong> - Open timer</div>
      <div><strong>P</strong> - Create partners</div>
      <div><strong>Enter</strong> - Generate question</div>
      <div><strong>Space</strong> - Random pick</div>
    </div>
  </div>
  
  <div style="margin-bottom: 20px;">
    <h3 style="color: #333; border-bottom: 2px solid #00d4ff; padding-bottom: 5px;">‚öôÔ∏è Features</h3>
    <p><strong>‚Ä¢</strong> AI-powered question generation with Ontario curriculum alignment</p>
    <p><strong>‚Ä¢</strong> Flexible response modes (2-4 choices, open-ended, would you rather)</p>
    <p><strong>‚Ä¢</strong> Student management with drag-and-drop functionality</p>
    <p><strong>‚Ä¢</strong> Timer, partner creation, and random student selection</p>
    <p><strong>‚Ä¢</strong> Layout saving and loading for different class configurations</p>
  </div>
  
  <div style="text-align: center; margin-top: 30px;">
    <button id="closeInfo" class="btn-primary" style="padding: 12px 24px; font-size: 16px;">Got it!</button>
  </div>
</div></div>

<!-- Roster modal -->
<div class="modal" id="rosterModal"><div class="sheet">
  <h2>üë• Edit roster (students only)</h2>
  <textarea id="rosterInput" style="width:100%;min-height:260px">Robyn
Layla
Keerthy
Hakim
Melania
Abbas
Penelope
Harnoor
Sean
Caleb
Elena
Selena
Anisha
Iris
Jazmine
Alayna
Shreyansh
August</textarea>
  <div class="row"><button id="applyRoster">Apply roster</button><button id="closeRoster">Cancel</button></div>
</div></div>

<!-- AI settings -->
<div class="modal" id="aiModal"><div class="sheet">
  <h2>ü§ñ AI Question Generator (Gemini)</h2>
  <p>A default API key is provided, but you can paste your own Google AI Studio key (saved locally in your browser).</p>
  <div class="row"><label style="min-width:140px">API Key</label><input id="aiKey" placeholder="AIza..." style="flex:1"/></div>
      <div class="row"><label style="min-width:140px">Model</label><input id="aiModel" placeholder="gemini-2.0-flash" style="flex:1"/></div>
  <div class="row"><label style="min-width:140px">Quick Switch:</label>
    <div style="flex:1;display:flex;gap:8px;">
      <button id="model2Flash" class="model-btn" style="padding:4px 8px;font-size:12px;">2.0 Flash</button>
      <button id="model1Flash" class="model-btn" style="padding:4px 8px;font-size:12px;">1.5 Flash</button>
      <button id="model1Pro" class="model-btn" style="padding:4px 8px;font-size:12px;">1.5 Pro</button>
    </div>
  </div>
          <div class="row">
          <span id="aiStatusDetail2" style="flex:1;font-weight:700;color:#94a3b8">Status: not checked</span>
          <div id="tokenProgress" style="display:inline-flex;align-items:center;margin-right:10px;font-size:12px;">
            <span id="tokenKeyName" style="margin-right:4px;color:#94a3b8;">main</span>
            <div style="width:40px;height:8px;background:#374151;border-radius:2px;overflow:hidden;border:1px solid #6b7280;">
              <div id="tokenProgressFill" style="width:100%;height:100%;background:#22c55e;transition:all 0.3s ease;"></div>
            </div>
            <span id="tokenProgressText" style="margin-left:4px;color:#94a3b8;">200</span>
          </div>
          <button id="aiTest">Test Connection</button>
        </div>
        <div style="margin-top:15px;padding:10px;background:#f8fafc;border-radius:6px;">
          <div style="font-weight:600;margin-bottom:8px;color:#374151;">API Key Selection:</div>
          <div style="display:flex;gap:8px;">
            <button id="keyMain" style="flex:1;padding:8px 12px;border:none;border-radius:4px;cursor:pointer;font-weight:500;background:#22c55e;color:white;">Main</button>
            <button id="keyBU1" style="flex:1;padding:8px 12px;border:none;border-radius:4px;cursor:pointer;font-weight:500;background:#6b7280;color:#d1d5db;">BU1</button>
            <button id="keyBU2" style="flex:1;padding:8px 12px;border:none;border-radius:4px;cursor:pointer;font-weight:500;background:#6b7280;color:#d1d5db;">BU2</button>
          </div>
        </div>
  <div style="height:10px"></div>
  <button id="aiSave" class="btn-primary">Save</button> <button id="aiClose" class="btn-ghost">Cancel</button>
</div></div>

<!-- Winner -->
<div class="modal" id="winnerModal"><div class="sheet" style="text-align:center">
  <h2 id="winnerText" style="font-size:clamp(28px,4.8vw,60px);margin:0 0 8px;color:#22c55e;"></h2>
  <div id="winnerSub" style="font-size:clamp(18px,2.4vw,30px);opacity:.9"></div>
  <button id="closeWinner" class="btn-primary">OK</button>
</div></div>

<div class="toast" id="toast"></div>
<div id="qDebug" style="display:none"></div>

<script>
(function(){
  console.log('=== SCRIPT STARTED ===');
  
  const SHOW_Q_DEBUG = false;

  // ---------- helpers ----------
  const $=s=>document.querySelector(s), $$=s=>Array.from(document.querySelectorAll(s));
  const raf=()=>new Promise(r=>requestAnimationFrame(()=>r()));
  const rect=el=>el.getBoundingClientRect();
  const center=el=>{const r=rect(el);return{x:r.left+r.width/2,y:r.top+r.height/2}};
  const within=(p,el)=>{const r=rect(el);return p.x>=r.left&&p.x<=r.right&&p.y>=r.top&&p.y<=r.bottom};
  const save=(k,v)=>localStorage.setItem(k,JSON.stringify(v));
  const load=(k,f)=>{try{const v=JSON.parse(localStorage.getItem(k));return v??f}catch{return f}};
  function toast(m){const t=$('#toast');t.textContent=m;t.classList.add('show');setTimeout(()=>t.classList.remove('show'),1700)}
  
  // ---------- Fullscreen functionality ----------
  function toggleFullscreen() {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.log('Error attempting to enable fullscreen:', err);
        toast('Fullscreen not supported');
      });
    } else {
      document.exitFullscreen();
    }
  }
  
  // Defensive: handle any soft-keyboard / toolbar changes
  const fit = () => {
    const app = document.getElementById('app');
    if (app) {
      // For SMART Boards, use a more conservative height to ensure bottom bar is visible
      let height = window.innerHeight;
      
      // If we're on a large display (like SMART Board), reduce height to account for browser interface
      if (window.innerWidth >= 3800 && window.innerHeight >= 2000) {
        height = Math.min(height, window.innerHeight * 0.85); // Use 85% of screen height
      } else if (window.visualViewport) {
        height = window.visualViewport.height;
      }
      
      app.style.height = height + 'px';
    }
  };
  
  // Add event listeners for fullscreen and viewport changes
  document.addEventListener('fullscreenchange', () => {
    const isFullscreen = !!document.fullscreenElement;
    const btn = $('#fullscreenBtn');
    if (btn) {
      btn.textContent = isFullscreen ? '[ ]' : '[ ]';
    }
  });
  
  addEventListener('resize', fit);
  addEventListener('orientationchange', fit);
  fit();
  
  // Fullscreen button click handler
  $('#fullscreenBtn').onclick = toggleFullscreen;
  
  // Fullscreen hotkeys
  document.addEventListener('keydown', (e) => {
    // +/= key to enter fullscreen
    if (e.key === '+' || e.key === '=') {
      if (!document.fullscreenElement) {
        e.preventDefault();
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Error attempting to enable fullscreen:', err);
          toast('Fullscreen not supported');
        });
      }
    }
    // -/_ key to exit fullscreen
    else if (e.key === '-' || e.key === '_') {
      if (document.fullscreenElement) {
        e.preventDefault();
        document.exitFullscreen();
      }
    }
    // Esc key to exit fullscreen
    else if (e.key === 'Escape') {
      if (document.fullscreenElement) {
        e.preventDefault();
        document.exitFullscreen();
      }
    }
  });
  
    // --------------- Simple AudioBank (Web Audio) ---------------
  class AudioBank {
    constructor() {
      this.ctx = null;
      this.master = null;
      this.loops = new Map();
      this.ready = false;
      this.audioQuality = 'high'; // 'high' or 'compatible'
      this.detectAudioQuality();
    }
    
    // Detect if we're on a lower-end system that needs audio compatibility mode
    detectAudioQuality() {
      try {
        // Check if we're on a SMART Board or similar system
        const isSMARTBoard = window.navigator.userAgent.includes('SMART') || 
                           window.navigator.userAgent.includes('Board') ||
                           window.screen.width >= 3000 || // Very wide screen
                           window.screen.height >= 2000;  // Very tall screen
        
        // Check Web Audio API support
        const audioContext = window.AudioContext || window.webkitAudioContext;
        if (!audioContext) {
          this.audioQuality = 'compatible';
          return;
        }
        
        // Test audio context creation
        const testCtx = new audioContext();
        if (testCtx.state === 'running' || testCtx.state === 'suspended') {
          testCtx.close();
        }
        
        // Check for manual override in localStorage
        const manualQuality = localStorage.getItem('mxq_audio_quality');
        if (manualQuality === 'high' || manualQuality === 'compatible') {
          this.audioQuality = manualQuality;
          console.log('Using manual audio quality setting:', manualQuality);
          return;
        }
        
        // Set quality based on system detection
        if (isSMARTBoard) {
          this.audioQuality = 'compatible';
          console.log('SMART Board detected - using compatible audio mode');
        } else {
          this.audioQuality = 'high';
          console.log('High-end system detected - using high-quality audio mode');
        }
      } catch (error) {
        console.log('Audio quality detection failed, using compatible mode:', error);
        this.audioQuality = 'compatible';
      }
    }
    
    // Manual audio quality toggle
    setAudioQuality(quality) {
      if (quality === 'high' || quality === 'compatible') {
        this.audioQuality = quality;
        localStorage.setItem('mxq_audio_quality', quality);
        console.log('Audio quality manually set to:', quality);
        
        // Stop any active loops to apply new settings
        this.stopShuffleLoop();
      }
    }
    
    // Get current audio quality setting
    getAudioQuality() {
      return this.audioQuality;
    }
    getCtx() {
      if(!this.ctx || this.ctx.state === 'closed') {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint: 'interactive'});
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.9;
        this.master.connect(this.ctx.destination);
      }
      if(this.ctx.state === 'suspended') this.ctx.resume();
      return this.ctx;
    }
    async init() {
      this.getCtx();
      this.ready = true;
    }
    // Synthesized SMB3 coin sound - SMART Board compatible version
    playCoin({volume=1, rate=1, detune=0}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // SMB3 coin: use triangle wave for better compatibility, with fallback
      const o = ctx.createOscillator();
      // Try triangle first, fallback to sine if triangle isn't supported
      try {
        o.type = 'triangle';
      } catch {
        o.type = 'sine';
      }
      o.frequency.setValueAtTime(1568 * rate, t0);
      if('detune' in o) o.detune.value = detune;
      
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(volume * 0.7, t0 + 0.002); // Gentler attack
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.08); // Slightly longer decay
      
      o.connect(g).connect(this.master);
      o.start(t0);
      o.stop(t0 + 0.1);
    }
    // Synthesized SMB3 1-UP sound
    playOneUp({volume=1, rate=1}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // SMB3 1-UP: ascending triad with sparkle
      const notes = [
        {f: 988, d: 0.08},   // B5
        {f: 1318.5, d: 0.08}, // E6
        {f: 1760, d: 0.12}    // A6
      ];
      
      let time = t0;
      notes.forEach((note, i) => {
        const o = ctx.createOscillator();
        o.type = 'square';
        o.frequency.setValueAtTime(note.f * rate, time);
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(volume * 0.6, time + 0.002);
        g.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
        
        o.connect(g).connect(this.master);
        o.start(time);
        o.stop(time + note.d + 0.02);
        
        time += note.d * 0.9; // slight overlap
      });
      
      // Sparkle at the end
      setTimeout(() => {
        const s = ctx.createOscillator();
        s.type = 'triangle';
        s.frequency.setValueAtTime(2349.3 * rate, ctx.currentTime);
        
        const sg = ctx.createGain();
        sg.gain.setValueAtTime(0.0001, ctx.currentTime);
        sg.gain.exponentialRampToValueAtTime(volume * 0.3, ctx.currentTime + 0.002);
        sg.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.1);
        
        s.connect(sg).connect(this.master);
        s.start();
        s.stop(ctx.currentTime + 0.12);
      }, (time - t0) * 1000);
    }
    
    // Alternative: Victory Fanfare (C major ‚Üí G major ‚Üí C major)
    playVictoryFanfare({volume=1, rate=1}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // C major ‚Üí G major ‚Üí C major progression
      const chords = [
        [{f: 523.25, d: 0.3}, {f: 659.25, d: 0.3}, {f: 783.99, d: 0.3}], // C major
        [{f: 783.99, d: 0.3}, {f: 987.77, d: 0.3}, {f: 1174.66, d: 0.3}], // G major
        [{f: 1046.5, d: 0.4}, {f: 1318.5, d: 0.4}, {f: 1567.98, d: 0.4}]  // C major (octave up)
      ];
      
      chords.forEach((chord, chordIndex) => {
        const chordTime = t0 + chordIndex * 0.35;
        chord.forEach(note => {
          const o = ctx.createOscillator();
          o.type = 'square';
          o.frequency.setValueAtTime(note.f * rate, chordTime);
          
          const g = ctx.createGain();
          g.gain.setValueAtTime(0.0001, chordTime);
          g.gain.exponentialRampToValueAtTime(volume * 0.4, chordTime + 0.01);
          g.gain.exponentialRampToValueAtTime(0.0001, chordTime + note.d);
          
          o.connect(g).connect(this.master);
          o.start(chordTime);
          o.stop(chordTime + note.d + 0.02);
        });
      });
    }
    
    // Alternative: Power-Up Arpeggio (A major ascending)
    playPowerUp({volume=1, rate=1}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // A major arpeggio: A5 ‚Üí C#6 ‚Üí E6 ‚Üí A6 ‚Üí C#7
      const notes = [
        {f: 880, d: 0.06},    // A5
        {f: 1108.73, d: 0.06}, // C#6
        {f: 1318.5, d: 0.06},  // E6
        {f: 1760, d: 0.08},    // A6
        {f: 2217.46, d: 0.1}   // C#7
      ];
      
      let time = t0;
      notes.forEach((note, i) => {
        const o = ctx.createOscillator();
        o.type = 'square';
        o.frequency.setValueAtTime(note.f * rate, time);
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(volume * 0.5, time + 0.002);
        g.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
        
        o.connect(g).connect(this.master);
        o.start(time);
        o.stop(time + note.d + 0.02);
        
        time += note.d * 0.85; // tight overlap
      });
    }
    
    // Alternative: Star Power (ascending glissando with sparkle)
    playStarPower({volume=1, rate=1}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // Glissando from C5 to C7
      const o = ctx.createOscillator();
      o.type = 'triangle';
      o.frequency.setValueAtTime(523.25 * rate, t0);
      o.frequency.exponentialRampToValueAtTime(2093 * rate, t0 + 0.4);
      
      const g = ctx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(volume * 0.6, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.4);
      
      o.connect(g).connect(this.master);
      o.start(t0);
      o.stop(t0 + 0.45);
      
      // Sparkle effect at the end
      setTimeout(() => {
        for(let i = 0; i < 5; i++) {
          setTimeout(() => {
            const s = ctx.createOscillator();
            s.type = 'sine';
            s.frequency.setValueAtTime((2000 + Math.random() * 1000) * rate, ctx.currentTime);
            
            const sg = ctx.createGain();
            sg.gain.setValueAtTime(0.0001, ctx.currentTime);
            sg.gain.exponentialRampToValueAtTime(volume * 0.2, ctx.currentTime + 0.001);
            sg.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.05);
            
            s.connect(sg).connect(this.master);
            s.start();
            s.stop(ctx.currentTime + 0.07);
          }, i * 30);
        }
      }, 400);
    }
    
    // Synthesized SMB3 Course Clear Fanfare (shortened version)
    playCourseClear({volume=1, rate=1}={}) {
      const ctx = this.getCtx();
      const t0 = ctx.currentTime;
      
      // Just the first 4 notes
      const notes = [
        {f: 523.25, d: 0.15},  // C5 (first)
        {f: 659.25, d: 0.15},  // E5 (second)
        {f: 783.99, d: 0.15},  // G5 (third)
        {f: 1046.5, d: 0.2}    // C6 (fourth)
      ];
      
      let time = t0;
      
      // Play the 5 notes
      notes.forEach((note, index) => {
        const o = ctx.createOscillator();
        o.type = 'square';
        o.frequency.setValueAtTime(note.f * rate, time);
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(volume * 0.5, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
        
        o.connect(g).connect(this.master);
        o.start(time);
        o.stop(time + note.d + 0.02);
        
        time += note.d * 0.9;
      });
      
      // Final sparkle effect
      setTimeout(() => {
        for(let i = 0; i < 5; i++) {
          setTimeout(() => {
            const s = ctx.createOscillator();
            s.type = 'triangle';
            s.frequency.setValueAtTime((1500 + Math.random() * 1000) * rate, ctx.currentTime);
            
            const sg = ctx.createGain();
            sg.gain.setValueAtTime(0.0001, ctx.currentTime);
            sg.gain.exponentialRampToValueAtTime(volume * 0.3, ctx.currentTime + 0.001);
            sg.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.08);
            
            s.connect(sg).connect(this.master);
            s.start();
            s.stop(ctx.currentTime + 0.1);
          }, i * 50);
        }
      }, (time - t0 + 0.2) * 1000);
    }
    // Synthesized shuffle loop - SMART Board compatible version
    startShuffleLoop({volume=0.6, rate=1}={}) {
      this.stopShuffleLoop();
      const ctx = this.getCtx();
      
      // Adjust settings based on detected audio quality
      const isCompatible = this.audioQuality === 'compatible';
      
      const playShuffleTick = () => {
        const o = ctx.createOscillator();
        
        if (isCompatible) {
          // Compatible mode: sine wave, lower frequency, gentler settings
          o.type = 'sine';
          o.frequency.setValueAtTime(500 * rate, ctx.currentTime); // Even lower frequency
        } else {
          // High quality mode: triangle wave, higher frequency, crisp settings
          o.type = 'triangle';
          o.frequency.setValueAtTime(800 * rate, ctx.currentTime);
        }
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, ctx.currentTime);
        
        if (isCompatible) {
          // Gentler attack and longer decay for compatibility
          g.gain.exponentialRampToValueAtTime(volume * 0.25, ctx.currentTime + 0.003);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.12);
        } else {
          // Crisp attack and quick decay for high quality
          g.gain.exponentialRampToValueAtTime(volume * 0.4, ctx.currentTime + 0.001);
          g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.06);
        }
        
        o.connect(g).connect(this.master);
        o.start();
        o.stop(ctx.currentTime + (isCompatible ? 0.15 : 0.08));
      };
      
      // Adjust interval based on audio quality
      const interval = setInterval(playShuffleTick, isCompatible ? 180 : 120);
      this.loops.set('shuffle', {interval});
    }
    stopShuffleLoop() {
      const rec = this.loops.get('shuffle');
      if(rec && rec.interval) {
        clearInterval(rec.interval);
        this.loops.delete('shuffle');
      }
    }
  }

  // ------------------ Instantiate bank ------------------
  const SFX = new AudioBank();

  // Confetti animation function
  function createConfetti() {
    console.log('createConfetti called');
    try {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#8800ff'];
      const confettiCount = 100;
      
      for (let i = 0; i < confettiCount; i++) {
        const confetti = document.createElement('div');
        confetti.style.position = 'fixed';
        confetti.style.width = '10px';
        confetti.style.height = '10px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = Math.random() * window.innerWidth + 'px';
        confetti.style.top = '-10px';
        confetti.style.zIndex = '10003'; // Higher than winner modal (10002)
        confetti.style.pointerEvents = 'none';
        confetti.style.borderRadius = '50%';
        
        document.body.appendChild(confetti);
        
        // Animate confetti falling from the modal area
        const animation = confetti.animate([
          { transform: 'translateY(0px) rotate(0deg)', opacity: 1 },
          { transform: `translateY(${window.innerHeight + 100}px) rotate(${Math.random() * 360}deg)`, opacity: 0 }
        ], {
          duration: 3000 + Math.random() * 2000,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        });
        
        animation.onfinish = () => {
          document.body.removeChild(confetti);
        };
      }
      console.log('Confetti created successfully');
    } catch (error) {
      console.error('Error creating confetti:', error);
    }
  }
  
  // === Winner celebration functions ===
  
  // Short 1-UP sound for quick wins
  function playApplause() {
    try {
      // Winner = classic SMB3 1-UP
      SFX.playOneUp({ volume: 0.95, rate: 1 });
    } catch {}
  }
  
  // Longer course clear fanfare for major victories
  function applauseFanfare() {
    try {
      // Stop any shuffle loops first
      SFX.stopShuffleLoop();
      
      // Play first 4 notes of course clear fanfare, then 1-UP sound
      const ctx = SFX.getCtx();
      const t0 = ctx.currentTime;
      
      // First 4 notes of course clear fanfare
      const notes = [
        {f: 523.25, d: 0.15},  // C5 (first)
        {f: 659.25, d: 0.15},  // E5 (second)
        {f: 783.99, d: 0.15},  // G5 (third)
        {f: 1046.5, d: 0.2}    // C6 (fourth)
      ];
      
      let time = t0;
      
      // Play the 4 notes
      notes.forEach((note, index) => {
        const o = ctx.createOscillator();
        o.type = 'square';
        o.frequency.setValueAtTime(note.f, time);
        
        const g = ctx.createGain();
        g.gain.setValueAtTime(0.0001, time);
        g.gain.exponentialRampToValueAtTime(0.95 * 0.5, time + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, time + note.d);
        
        o.connect(g).connect(SFX.master);
        o.start(time);
        o.stop(time + note.d + 0.02);
        
        time += note.d * 0.9;
      });
      
      // After the 4 notes, play the 1-UP sound
      setTimeout(() => {
        SFX.playOneUp({ volume: 0.95, rate: 1 });
      }, (time - t0 + 0.2) * 1000);
      
    } catch {}
  }

  // ---------- QUESTION: hard replace + live region + repaint ----------
  function updateQDebug(){
    if(!SHOW_Q_DEBUG) return;
    const box = document.getElementById('qDebug');
    const last = localStorage.getItem('mxq_last_question_raw') || '(none)';
    const meta = localStorage.getItem('mxq_ai_lastgen') || '(no meta)';
    const wasRepaired = localStorage.getItem('mxq_question_repaired') === 'true';
    box.style.display='block';
    box.textContent = `Q(raw): ${last}  |  meta: ${meta}${wasRepaired ? ' | REPAIRED' : ''}`;
  }
  async function renderQuestionForce(text){
    console.log('renderQuestionForce called with:', text);
    const row = document.querySelector('.questionRow');
    const old = document.getElementById('question');
    console.log('Found question row:', row);
    console.log('Found old question element:', old);
    console.log('Question row exists:', !!row);
    console.log('Old question element exists:', !!old);
    
    const n = document.createElement('div');
    n.className = old.className; n.id = 'question';
    n.textContent = text || '‚Äî';
    console.log('Created new question element with text:', n.textContent);
    
    // replace node
    row.replaceChild(n, old);
    console.log('Replaced question element');
    
    // Adjust font size to fit on 2 lines
    adjustQuestionFontSize(n);
    
    // live region update for AT + paint
    const live = document.getElementById('qLive');
    live.textContent = text || '‚Äî';
    console.log('Updated live region with text:', live.textContent);
    
    // Repaint nudges
    await raf(); await raf();
    n.style.transform='translateZ(0)'; // promote
    void n.offsetHeight;
    // tiny swap to force glyph rasterization
    n.textContent = (text||'‚Äî') + '\u00A0';
    await raf();
    n.textContent = (text||'‚Äî');
    console.log('Final question element text:', n.textContent);
    
    // Force a complete refresh of the question field
    setTimeout(() => {
      const finalQuestion = document.getElementById('question');
      console.log('Question element after timeout:', finalQuestion);
      console.log('Question element text content after timeout:', finalQuestion?.textContent);
      
      // If the question still doesn't match, force update it
      if (finalQuestion && finalQuestion.textContent !== text) {
        console.log('Question content mismatch detected, forcing update...');
        finalQuestion.textContent = text;
        console.log('Forced question update to:', finalQuestion.textContent);
      }
    }, 50);
  }
  
  function adjustQuestionFontSize(questionEl) {
    const maxHeight = 2.4; // 2 lines * 1.2 line-height
    let fontSize = parseFloat(window.getComputedStyle(questionEl).fontSize);
    const originalFontSize = fontSize;
    
    // Reset to original size first
    questionEl.style.fontSize = originalFontSize + 'px';
    
    // Check if content overflows and reduce font size until it fits
    while (questionEl.scrollHeight > questionEl.clientHeight && fontSize > 16) {
      fontSize -= 2;
      questionEl.style.fontSize = fontSize + 'px';
    }
    
    // Force a reflow to ensure the height calculation is accurate
    questionEl.offsetHeight;
    
    // Double-check and reduce more if needed
    if (questionEl.scrollHeight > questionEl.clientHeight && fontSize > 12) {
      fontSize -= 4;
      questionEl.style.fontSize = fontSize + 'px';
    }
  }
  function setQuestionSafe(q, wasRepaired = false, fromBank = false, isManual = false){
    console.log('setQuestionSafe called with:', q, 'wasRepaired:', wasRepaired, 'fromBank:', fromBank, 'isManual:', isManual);
    let text = (q||'').trim();
    console.log('Trimmed text:', text);
    localStorage.setItem('mxq_last_question_raw', text);
    
    // Track if this question was repaired
    if (wasRepaired) {
      localStorage.setItem('mxq_question_repaired', 'true');
      console.log('Question marked as repaired');
    } else {
      localStorage.removeItem('mxq_question_repaired');
    }
    
    // Show/hide manual indicator (green M)
    const manualIndicator = document.getElementById('manualIndicator');
    if (manualIndicator) {
      if (isManual) {
        manualIndicator.style.display = 'flex';
        manualIndicator.title = 'Manual question (typed or edited)';
      } else {
        manualIndicator.style.display = 'none';
        manualIndicator.title = '';
      }
    }
    
    // Show/hide AI indicator (white A) - only if not manual
    const aiIndicator = document.getElementById('aiIndicator');
    if (aiIndicator) {
      if (!fromBank && !isManual) {
        aiIndicator.style.display = 'flex';
        aiIndicator.title = 'AI generated question';
      } else {
        aiIndicator.style.display = 'none';
        aiIndicator.title = '';
      }
    }
    
    // Show/hide bank indicator (grey B) - only if not manual
    const bankIndicator = document.getElementById('bankIndicator');
    if (bankIndicator) {
      if (fromBank && !isManual) {
        bankIndicator.style.display = 'flex';
        bankIndicator.title = 'Question from offline bank';
      } else {
        bankIndicator.style.display = 'none';
        bankIndicator.title = '';
      }
    }
    
    if(!text || text.replace(/\s+/g,'').length<2){
      console.log('Question too short, using fallback');
      const grade=load('mxq_grade',''), subject=load('mxq_subject',''), blooms=load('mxq_blooms','');
      const verbMap={Remember:'show what you know',Understand:'explain your thinking',Apply:'use your skills',Analyze:'compare or find a pattern',Evaluate:'choose and justify',Create:'plan or design'};
      const verb=verbMap[blooms]||'explain your thinking';
      text = subject!=='General'?`How will you ${verb} in ${subject} today?`:`What is one smart way you can ${verb} today?`;
      localStorage.setItem('mxq_ai_lastgen', JSON.stringify({questionSource:'fallback',time:Date.now()}));
    } else {
      console.log('Using AI-generated question');
      const prev = JSON.parse(localStorage.getItem('mxq_ai_lastgen')||'{}');
      localStorage.setItem('mxq_ai_lastgen', JSON.stringify({...prev,questionSource:'model',time:Date.now()}));
    }
    
    console.log('About to render question:', text);
    console.log('Calling renderQuestionForce with text:', text);
    renderQuestionForce(text).then(() => {
      console.log('Question rendering complete');
      updateQDebug();
      
      // Check if the question is actually in the DOM
      const questionElement = document.getElementById('question');
      console.log('Question element after render:', questionElement);
      console.log('Question element text content:', questionElement?.textContent);
      
      // Also update the qInput field in settings if it exists
      const qInput = document.getElementById('qInput');
      if (qInput) {
        qInput.value = text;
        console.log('Updated qInput field with:', text);
      }
    }).catch(error => {
      console.error('Error in renderQuestionForce:', error);
    });
  }
  // If anything empties the question, restore it
  const mo=new MutationObserver(()=>{
    const q=document.getElementById('question');
    if(q && (!q.textContent || q.textContent.trim()==='')){
      console.log('Mutation observer detected empty question, restoring...');
      const last=localStorage.getItem('mxq_last_question_raw')||'‚Äî';
      console.log('Restoring question to:', last);
      renderQuestionForce(last);
    }
  });
  mo.observe(document.body,{subtree:true,childList:true,characterData:true});
  
  // Add event listeners to detect manual question editing
  document.addEventListener('DOMContentLoaded', () => {
    const qInput = document.getElementById('qInput');
    if (qInput) {
      // Detect when user manually types in the question field
      qInput.addEventListener('input', () => {
        const typedQuestion = qInput.value.trim();
        const currentQuestion = $('#question')?.textContent?.trim() || '';
        
        // If the typed question is different from current and not empty, show manual indicator
        if (typedQuestion !== currentQuestion && typedQuestion.length > 0) {
          // Show manual indicator temporarily while typing
          const manualIndicator = document.getElementById('manualIndicator');
          if (manualIndicator) {
            manualIndicator.style.display = 'flex';
            manualIndicator.title = 'Manual question (typing...)';
          }
          
          // Hide other indicators while manually editing
          const aiIndicator = document.getElementById('aiIndicator');
          const bankIndicator = document.getElementById('bankIndicator');
          if (aiIndicator) aiIndicator.style.display = 'none';
          if (bankIndicator) bankIndicator.style.display = 'none';
        }
      });
      
      // When user finishes editing (blur event), update the question if it's different
      qInput.addEventListener('blur', () => {
        const typedQuestion = qInput.value.trim();
        const currentQuestion = $('#question')?.textContent?.trim() || '';
        
        if (typedQuestion !== currentQuestion && typedQuestion.length > 0) {
          console.log('Manual question detected, updating...');
          setQuestionSafe(typedQuestion, false, false, true);
        }
      });
    }
    
    // Add event listeners to detect manual choice editing
    ['a1', 'a2', 'a3', 'a4'].forEach(id => {
      const choiceInput = document.getElementById(id);
      if (choiceInput) {
        choiceInput.addEventListener('input', () => {
          // If any choice is manually edited, show manual indicator
          const manualIndicator = document.getElementById('manualIndicator');
          if (manualIndicator) {
            manualIndicator.style.display = 'flex';
            manualIndicator.title = 'Manual choices (editing...)';
          }
          
          // Hide other indicators while manually editing
          const aiIndicator = document.getElementById('aiIndicator');
          const bankIndicator = document.getElementById('bankIndicator');
          if (aiIndicator) aiIndicator.style.display = 'none';
          if (bankIndicator) bankIndicator.style.display = 'none';
        });
        
        // When user finishes editing choices, mark as manual
        choiceInput.addEventListener('blur', () => {
          const currentQuestion = $('#question')?.textContent?.trim() || '';
          if (currentQuestion) {
            // Mark the current question as manual since choices were edited
            setQuestionSafe(currentQuestion, false, false, true);
          }
        });
      }
    });
  });

  // ---------- zones / choices ----------
  function setCols(n){$('#zones').style.gridTemplateColumns=`repeat(${n},minmax(0,1fr))`}
  function buildZones(choices,colors){
    const wrap=$('#zones'); wrap.innerHTML=''; setCols(choices.length);
    choices.forEach((c,i)=>{const z=document.createElement('div'); z.className='zone '+(colors?.[i]||['blue','red','green','purple'][i%4]); z.dataset.zone=i; const h=document.createElement('h3'); h.textContent=c; z.appendChild(h); wrap.appendChild(z);});
  }
  function ensureEmojis(choices){
    // add emoji if none detected on any; keep if already present
    const hasAny = choices.some(c=>/^\p{Emoji}/u.test(c));
    if(hasAny) return choices;
    const pool=["ü§ù","üé≤","üìñ","üîÑ","üé®","‚òÄÔ∏è","üë´","üèÉ","üéµ","üé≠","üçé","üåé","üß©","‚úèÔ∏è","üñåÔ∏è","‚öΩ","üé∂","ü¶ã","üöÄ","ü™¥","üïäÔ∏è","üîç","üß†","üí°","üõ†Ô∏è","ÔøΩÔøΩÔ∏è","üß™","üìê","üßÆ","üó£Ô∏è"];
    const used=new Set();
    return choices.map(c=>{let e=pool.find(x=>!used.has(x))||"üéØ"; used.add(e); return `${e} ${c}`});
  }
  function applyChoices(mode,lines){
    let choices=[];
    if(mode==='open'){choices=['üó£Ô∏è I\'ve got my answer and I\'m ready to explain it.']}
    else{
      const n=Math.max(2,Math.min(4,parseInt(mode,10)||4));
      choices=lines.slice(0,n).filter(Boolean);
      if(n>=3){
        const haveOther=choices.some(c=>/other/i.test(c));
        const final = haveOther? choices.filter(c=>!/other/i.test(c)).concat('Other (explain)') : choices.slice(0,n-1).concat('Other (explain)');
        choices=final;
      }
    }
    if(mode==='wyr'){
      choices=lines.slice(0,2).filter(Boolean);
    }
    choices = ensureEmojis(choices); // <- keep emojis at start
    const colors=choices.map((_,i)=>['blue','red','green','purple'][i%4]);
    buildZones(choices,colors);
    // Don't overwrite the question when saving choices
    const currentQ = $('#question').textContent || localStorage.getItem('mxq_last_question_raw') || '';
    save('mxq_choices',{q:currentQ,choices,colors,mode});
    stats();
  }

  // ---------- parking + badges + auto-bump ----------
  const TEACHER='Mr. Cushman';
  let roster=[], badges=[], activeDrags=new Map(), pickedSet=new Set();
  function parkingGrid(){const pad=$('#parkingPad'), rs=$('#stage').getBoundingClientRect(); const r=pad.getBoundingClientRect(); const topPad=42; const left0=r.left-rs.left+20, top0=r.top-rs.top+topPad, usableW=r.width-40; return {left0, top0, cols:Math.max(4,Math.floor(usableW/140))};}
  function distribute(resetAll=false){
    const g=parkingGrid(); let i=0;
    
    // Get all student badges (excluding teacher)
    const studentBadges = badges.filter(b => b.dataset.ignore !== 'true');
    
    // Calculate optimal spacing to ensure no overlap
    const badgeWidth = 140;
    const badgeHeight = 64;
    const spacing = 10; // Extra space between badges
    
    studentBadges.forEach(b => {
      if (!resetAll && b.dataset.zone !== 'parking') return;
      
      const col = i % g.cols;
      const row = Math.floor(i / g.cols);
      
      // Position with proper spacing
      const x = g.left0 + col * (badgeWidth + spacing);
      const y = g.top0 + row * (badgeHeight + spacing);
      
      b.style.left = x + 'px';
      b.style.top = y + 'px';
      b.dataset.zone = 'parking';
      b.dataset.lastX = b.style.left;
      b.dataset.lastY = b.style.top;
      b.classList.add('inParking');
      i++;
    });
    
    // Position teacher badge with proper spacing
    const t = badges.find(b => b.dataset.ignore === 'true');
    if (t) {
      const col = i % g.cols;
      const row = Math.floor(i / g.cols);
      
      const x = g.left0 + col * (badgeWidth + spacing);
      const y = g.top0 + row * (badgeHeight + spacing);
      
      t.style.left = x + 'px';
      t.style.top = y + 'px';
      t.dataset.zone = 'parking';
      t.dataset.lastX = t.style.left;
      t.dataset.lastY = t.style.top;
      t.classList.add('inParking');
    }
    
    // Ensure all badges are accessible and properly positioned
    badges.forEach(b => {
      if (b.dataset.zone === 'parking') {
        // Reset any problematic styles that might interfere with interaction
        b.style.pointerEvents = 'auto';
        b.style.opacity = '1';
        b.style.visibility = 'visible';
        b.style.zIndex = '1';
        
        // Ensure the badge is within the visible area
        const rect = b.getBoundingClientRect();
        const stageRect = $('#stage').getBoundingClientRect();
        
        // If badge is outside the stage area, reposition it
        if (rect.right < stageRect.left || rect.left > stageRect.right || 
            rect.bottom < stageRect.top || rect.top > stageRect.bottom) {
          // Reposition to a safe location within the parking area
          const safeX = Math.max(stageRect.left + 20, Math.min(stageRect.right - 160, parseInt(b.style.left) || 0));
          const safeY = Math.max(stageRect.top + 20, Math.min(stageRect.bottom - 84, parseInt(b.style.top) || 0));
          
          b.style.left = safeX + 'px';
          b.style.top = safeY + 'px';
          b.dataset.lastX = b.style.left;
          b.dataset.lastY = b.style.top;
        }
      }
    });
  }
  function makeBadges(){
    $('#badgeLayer').innerHTML=''; badges=[];
    const g=parkingGrid(); let i=0;
    roster.forEach(name=>{
      const el=document.createElement('div'); el.className='badge inParking'; el.textContent=name; el.setAttribute('draggable','false'); el.ondragstart=()=>false;
      const col=i%g.cols,row=Math.floor(i/g.cols);
      el.style.left=(g.left0+col*140)+'px'; el.style.top=(g.top0+row*64)+'px';
      el.dataset.zone='parking'; el.dataset.lastX=el.style.left; el.dataset.lastY=el.style.top;
      // Ensure the badge is accessible
      el.style.pointerEvents = 'auto';
      el.style.cursor = 'grab';
      el.style.opacity = '1';
      el.style.visibility = 'visible';
      
      $('#badgeLayer').appendChild(el); enableDrag(el); badges.push(el); i++;
    });
    i++;
    const t=document.createElement('div'); t.className='badge teacher inParking'; t.textContent=TEACHER; t.setAttribute('draggable','false'); t.ondragstart=()=>false;
    const col=i%g.cols,row=Math.floor(i/g.cols);
    t.style.left=(g.left0+col*140)+'px'; t.style.top=(g.top0+row*64)+'px';
    t.dataset.zone='parking'; t.dataset.ignore='true'; t.dataset.lastX=t.style.left; t.dataset.lastY=t.style.top;
    $('#badgeLayer').appendChild(t); enableDrag(t); badges.push(t);
    stats();
  }
  function enableDrag(el){
    // Ensure the element is always draggable
    el.style.pointerEvents = 'auto';
    el.style.cursor = 'grab';
    
    el.addEventListener('pointerdown', e => {
      e.preventDefault();
      el.setPointerCapture(e.pointerId);
      const r = el.getBoundingClientRect();
      activeDrags.set(e.pointerId, {
        el,
        dx: e.clientX - r.left,
        dy: e.clientY - r.top
      });
      
      // Bring this badge to the top layer when starting to drag
      const maxZIndex = Math.max(...badges.map(b => parseInt(b.style.zIndex) || 1));
      el.style.zIndex = maxZIndex + 1;
      el.style.cursor = 'grabbing';
    }, { passive: false });

    el.addEventListener('pointermove', e => {
      const d = activeDrags.get(e.pointerId);
      if (!d || d.el !== el) return;
      const s = $('#stage').getBoundingClientRect();
      el.style.left = (e.clientX - s.left - d.dx) + 'px';
      el.style.top = (e.clientY - s.top - d.dy) + 'px';
    });

    const end = e => {
      const d = activeDrags.get(e.pointerId);
      if (!d || d.el !== el) return;
      settle(el);
      activeDrags.delete(e.pointerId);
      el.releasePointerCapture?.(e.pointerId);
    };
    el.addEventListener('pointerup', end);
    el.addEventListener('pointercancel', end);
    el.addEventListener('pointerleave', end);
    el.addEventListener('pointerout', end);
  }
  function zoneSlots(zoneEl){
    // returns an array of absolute positions inside zone where a badge could snap, avoiding the title
    const sR=$('#stage').getBoundingClientRect();
    const zR=zoneEl.getBoundingClientRect();
    const h=zoneEl.querySelector('h3');
    const headBottom = h? h.getBoundingClientRect().bottom : zR.top+10;
    const startY = headBottom + 8 - sR.top;
    const left = zR.left - sR.left + 10;
    const right = zR.right - sR.left - 10;
    const width = right - left;
    const cols = Math.max(1, Math.floor(width/140));
    const rows = 6; // plenty
    const out=[];
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        out.push({x:left + c*140, y:startY + r*64});
      }
    }
    return out;
  }
  function overlaps(a,b){
    const ax=parseFloat(a.style.left), ay=parseFloat(a.style.top);
    const bx=parseFloat(b.style.left), by=parseFloat(b.style.top);
    return Math.abs(ax-bx)<130 && Math.abs(ay-by)<56; // rough badge footprint
  }
  function placeInZone(el, zoneEl){
    // Allow completely free placement - no constraints at all
    // Just determine which zone the badge belongs to based on where the majority is
    const badgeRect = el.getBoundingClientRect();
    const zoneRect = zoneEl.getBoundingClientRect();
    
    // Calculate how much of the badge overlaps with this zone
    const overlapLeft = Math.max(badgeRect.left, zoneRect.left);
    const overlapRight = Math.min(badgeRect.right, zoneRect.right);
    const overlapTop = Math.max(badgeRect.top, zoneRect.top);
    const overlapBottom = Math.min(badgeRect.bottom, zoneRect.bottom);
    
    const overlapWidth = Math.max(0, overlapRight - overlapLeft);
    const overlapHeight = Math.max(0, overlapBottom - overlapTop);
    const overlapArea = overlapWidth * overlapHeight;
    const badgeArea = badgeRect.width * badgeRect.height;
    
    // If more than 50% of the badge is in this zone, assign it here
    if (overlapArea > badgeArea * 0.5) {
      el.dataset.zone = zoneEl.dataset.zone;
      el.dataset.lastX = el.style.left;
      el.dataset.lastY = el.style.top;
      el.classList.remove('inParking');
      el.style.zIndex = Date.now();
      return true;
    }
    
    return false;
  }
  function settle(el){
    const pt=center(el), targets=[...document.querySelectorAll('.zone'),$('#parkingPad'),$('#partnerArea'),$('#helpArea')];
    let landed=false;
    
    // For completely free placement, just determine which zone the badge belongs to
    for(const t of targets){
      if(t.id==='parkingPad'){
        // Check if badge is mostly in parking area
        const badgeRect = el.getBoundingClientRect();
        const parkingRect = t.getBoundingClientRect();
        const overlapLeft = Math.max(badgeRect.left, parkingRect.left);
        const overlapRight = Math.min(badgeRect.right, parkingRect.right);
        const overlapTop = Math.max(badgeRect.top, parkingRect.top);
        const overlapBottom = Math.min(badgeRect.bottom, parkingRect.bottom);
        const overlapWidth = Math.max(0, overlapRight - overlapLeft);
        const overlapHeight = Math.max(0, overlapBottom - overlapTop);
        const overlapArea = overlapWidth * overlapHeight;
        const badgeArea = badgeRect.width * badgeRect.height;
        
        if (overlapArea > badgeArea * 0.5) {
          el.dataset.zone='parking';
          el.dataset.lastX=el.style.left; el.dataset.lastY=el.style.top;
          el.classList.add('inParking');
          
          // Ensure this badge stays on top since it was just moved
          const maxZIndex = Math.max(...badges.map(b => parseInt(b.style.zIndex) || 1));
          el.style.zIndex = maxZIndex + 1;
          
          landed=true; break;
        }
      }else if(t.id==='partnerArea' || t.id==='helpArea'){
        // Check if badge is mostly in helper area - allow placement anywhere in the area
        const badgeRect = el.getBoundingClientRect();
        const areaRect = t.getBoundingClientRect();
        const overlapLeft = Math.max(badgeRect.left, areaRect.left);
        const overlapRight = Math.min(badgeRect.right, areaRect.right);
        const overlapTop = Math.max(badgeRect.top, areaRect.top);
        const overlapBottom = Math.min(badgeRect.bottom, areaRect.bottom);
        const overlapWidth = Math.max(0, overlapRight - overlapLeft);
        const overlapHeight = Math.max(0, overlapBottom - overlapTop);
        const overlapArea = overlapWidth * overlapHeight;
        const badgeArea = badgeRect.width * badgeRect.height;
        
        // If any part of the badge is in the helper area, allow placement
        if (overlapArea > 0) {
          el.dataset.zone = t.id === 'partnerArea' ? 'partner' : 'help';
          el.dataset.lastX=el.style.left; el.dataset.lastY=el.style.top;
          el.classList.remove('inParking');
          
          // Ensure this badge stays on top since it was just moved
          const maxZIndex = Math.max(...badges.map(b => parseInt(b.style.zIndex) || 1));
          el.style.zIndex = maxZIndex + 1;
          
          landed=true; break;
        }
      }else{
        // Check if badge is mostly in response zone
        const badgeRect = el.getBoundingClientRect();
        const zoneRect = t.getBoundingClientRect();
        const overlapLeft = Math.max(badgeRect.left, zoneRect.left);
        const overlapRight = Math.min(badgeRect.right, zoneRect.right);
        const overlapTop = Math.max(badgeRect.top, zoneRect.top);
        const overlapBottom = Math.min(badgeRect.bottom, zoneRect.bottom);
        const overlapWidth = Math.max(0, overlapRight - overlapLeft);
        const overlapHeight = Math.max(0, overlapBottom - overlapTop);
        const overlapArea = overlapWidth * overlapHeight;
        const badgeArea = badgeRect.width * badgeRect.height;
        
        if (overlapArea > badgeArea * 0.5) {
          el.dataset.zone = t.dataset.zone;
          el.dataset.lastX=el.style.left; el.dataset.lastY=el.style.top;
          el.classList.remove('inParking');
          
          // Ensure this badge stays on top since it was just moved
          const maxZIndex = Math.max(...badges.map(b => parseInt(b.style.zIndex) || 1));
          el.style.zIndex = maxZIndex + 1;
          
          landed=true; break;
        }
      }
    }
    
    // Always allow the badge to stay where it was dropped, even if not in a recognized zone
    if(!landed){
      // Keep the badge where it was dropped, just update its last position
      el.dataset.lastX=el.style.left; el.dataset.lastY=el.style.top;
      
      // Ensure this badge stays on top since it was just moved
      const maxZIndex = Math.max(...badges.map(b => parseInt(b.style.zIndex) || 1));
      el.style.zIndex = maxZIndex + 1;
    }
    stats();
  }
  function stats(){
    const placed=$$('.badge:not(.inParking)').filter(b=>b.dataset.zone);
    const absent=$$('.badge.inParking').filter(b=>!b.textContent.includes('Mr. Cushman'));
    $('#placedCount').textContent='Placed: '+placed.length;
    $('#absentCount').textContent='Absent (not placed): '+absent.length;
  }

  // ---------- random picker ----------
  function weekKey(d=new Date()){const date=new Date(Date.UTC(d.getFullYear(),d.getMonth(),d.getDate()));const day=date.getUTCDay()||7;date.setUTCDate(date.getUTCDate()+4-day);const yearStart=new Date(Date.UTC(date.getUTCFullYear(),0,1));const weekNo=Math.ceil((((date-yearStart)/86400000)+1)/7);return date.getUTCFullYear()+'-W'+String(weekNo).padStart(2,'0')}
  function ensureWeek(){const cur=weekKey();const s=load('mxq_week'); if(s!==cur){save('mxq_week',cur);save('mxq_picked',[]); pickedSet.clear()} else {pickedSet=new Set(load('mxq_picked',[]))}}
  function persistPicked(){save('mxq_picked',Array.from(pickedSet))}
  function randomPick(){
    console.log('randomPick function called');
    try {
      // Get all students (not in parking, excluding Mr. Cushman)
    const allStudents = badges.filter(b => 
      b.dataset.ignore !== 'true' && 
      !b.textContent.includes('Mr. Cushman')
    );
    
    // Get placed students (not in parking) - includes all students outside parking lot
    const placedStudents = allStudents.filter(b => b.dataset.zone !== 'parking' && b.dataset.zone !== undefined);
    
    // Determine which students to select from
    let base;
    if(placedStudents.length === 0) {
      // If no students are placed (all in parking), select from all students
      base = allStudents;
    } else {
      // If some students are placed, select only from those outside parking lot
      base = placedStudents;
    }
    
    let pool=base.filter(b=>!pickedSet.has(b.textContent.trim()));
    if(pool.length===0){pickedSet.clear();persistPicked();pool=base.slice(); if(pool.length===0){toast('No students to pick from.'); return;} toast('New round this week!')}
    
    // Shuffle the pool to make selection truly random
    pool = pool.sort(() => Math.random() - 0.5);
    
    pool.forEach(b=>b.classList.remove('spinning','winner'));
    const rounds=Math.floor((Math.max(24,6+pool.length*2)*1.5)*0.75), baseDelay=40; let i=0;
    // === COIN TICK (sound-alike) ===
    // progress helper you already have: i / rounds  (0..1)
    function tick() {
      try {
        const progress = (typeof i !== "undefined" && typeof rounds !== "undefined") ? (i / Math.max(1, rounds)) : 0;

        // Tick that sounds like SMB3 coin; we modulate pitch & tiny jitter.
        const easing = (t)=>1-Math.pow(1-t,3); // easeOutCubic for rate drop
        const rate = 1.12 - easing(progress)*0.28; // 1.12 ‚Üí ~0.84
        const jitterCents = (Math.random()*10 - 5); // ¬±5 cents
        
        SFX.playCoin({ volume: 0.85, rate: Math.max(0.75, rate), detune: jitterCents });
      } catch {}
    }
    function win(){try{const c=new (window.AudioContext||window.webkitAudioContext)();const o=c.createOscillator(),g=c.createGain();o.type='triangle';o.frequency.value=620;g.gain.setValueAtTime(0.001,c.currentTime);g.gain.exponentialRampToValueAtTime(0.12,c.currentTime+0.02);g.gain.exponentialRampToValueAtTime(0.0001,c.currentTime+0.5);o.connect(g).connect(c.destination);o.start();o.stop(c.currentTime+0.55);setTimeout(()=>c.close(),600)}catch{}}
    function step(){
      console.log('Step function called, i:', i, 'rounds:', rounds, 'pool length:', pool.length);
      pool.forEach(b=>b.classList.remove('spinning'));
      const idx=i%pool.length; pool[idx].classList.add('spinning'); tick(); i++;
      const p=i/rounds, d=baseDelay+p*p*260;
      if(i<rounds) setTimeout(step,d); else{
        console.log('Winner selection reached!');
        pool.forEach(b=>b.classList.remove('spinning','winner'));
        const w=pool[(i-1)%pool.length]; w.classList.add('winner'); win();
        const z=w.dataset.zone; let ans=''; const zEl=document.querySelector(`.zone[data-zone="${z}"] h3`); if(zEl) ans=zEl.textContent.trim();
        const name=w.textContent.trim(); pickedSet.add(name); persistPicked(); setTimeout(()=>{w.classList.remove('winner'); stats()},120);
        console.log('Setting winner text to:', name);
        $('#winnerText').textContent=name; $('#winnerText').style.color='#22c55e'; 
        
        // Check if student is in parking lot or in a grouped response area
        const isInParking = z === 'parking';
        const isInGroupedResponse = z === '0' || z === 'partner' || z === 'help';
        
        if(isInParking || isInGroupedResponse) {
          // Student is in parking lot or grouped response - just say "please explain your answer"
          $('#winnerSub').textContent='please explain your answer.';
        } else {
          // Student is in a regular response zone - show the specific response
          $('#winnerSub').textContent=`please explain your answer: ${ans||'your choice'}`;
        }
        
        $('#winnerModal').classList.add('show');
        
        // Add celebration effects
        console.log('Triggering celebration effects for winner:', name);
        createConfetti();
        applauseFanfare();
      }
    }
    step();
    } catch (error) {
      console.error('Error in randomPick function:', error);
    }
  }
  $('#randomBtn').onclick=()=>{
    alert('Random button clicked!');
    console.log('Random button clicked!');
    randomPick();
  }; 
  $('#closeWinner').onclick=()=>{
    $('#winnerModal').classList.remove('show');
  };

  // ---------- AI (Gemini) ----------
  const GEMINI_MODEL_DEFAULT='gemini-2.0-flash';
  // API Keys - Main and 2 Backups
  const API_KEYS = {
    main: 'AIzaSyDpx9ITK7RRlxYgbVaF_gkDJAAdmkjBzoQ',
    BU1: 'AIzaSyAiH3K8dV-fQ5sRskV5elkw3zGj2UMAtTM',
    BU2: 'AIzaSyAqBvW8uSr6ie9PkM9XDL3zEMCjy07eCoY'
  };
  
  // Token tracking for each key
  const TOKEN_LIMITS = {
    main: 200,
    BU1: 200,
    BU2: 200
  };
  
  function getTokenUsage(keyName) {
    const usage = load(`mxq_token_usage_${keyName}`) || 0;
    return usage;
  }
  
  function incrementTokenUsage(keyName) {
    const currentUsage = getTokenUsage(keyName);
    const newUsage = currentUsage + 1;
    save(`mxq_token_usage_${keyName}`, newUsage);
    return newUsage;
  }
  
  function setTokenUsage(keyName, usage) {
    save(`mxq_token_usage_${keyName}`, usage);
    updateTokenProgress();
  }
  
  function simulateRateLimit(keyName) {
    localStorage.setItem('mxq_last_ai_error', 'Daily quota exceeded (200 requests). Resets at midnight Pacific Time.');
    localStorage.setItem('mxq_last_failed_key', keyName);
    updateTokenProgress();
    console.log('Simulated rate limit for key:', keyName);
  }
  
  function getTokenPercentage(keyName) {
    const usage = getTokenUsage(keyName);
    const limit = TOKEN_LIMITS[keyName];
    return Math.max(0, Math.min(100, ((limit - usage) / limit) * 100));
  }
  
  function updateTokenProgress() {
    const activeKey = getActiveKeyName();
    const usage = getTokenUsage(activeKey);
    const limit = TOKEN_LIMITS[activeKey];
    const remaining = Math.max(0, limit - usage);
    const percentage = Math.max(0, Math.min(100, (remaining / limit) * 100));
    
    const progressFill = document.getElementById('tokenProgressFill');
    const progressText = document.getElementById('tokenProgressText');
    const keyName = document.getElementById('tokenKeyName');
    
    if(progressFill && progressText && keyName) {
      // Set key name
      keyName.textContent = activeKey;
      
      // Check if this key is rate limited by looking at the AI status
      const aiStatus = load('mxq_ai_status');
      const lastError = localStorage.getItem('mxq_last_ai_error');
      const lastFailedKey = localStorage.getItem('mxq_last_failed_key');
      const isRateLimited = lastError && lastError.includes('quota exceeded') && lastFailedKey === activeKey;
      
      console.log('Token progress debug:', {
        activeKey,
        usage,
        remaining,
        percentage,
        lastError,
        lastFailedKey,
        isRateLimited,
        aiStatusOk: aiStatus ? aiStatus.ok : 'no status'
      });
      
      if(isRateLimited) {
        // Rate limited - show empty red bar
        progressFill.style.width = '0%';
        progressFill.style.background = '#ef4444'; // Red
        progressText.textContent = '0';
        progressFill.style.border = '1px solid #dc2626'; // Red border for emphasis
        console.log('Showing rate-limited (empty red bar)');
      } else {
        // Not rate limited - show actual usage
        progressFill.style.width = `${percentage}%`;
        progressFill.style.border = 'none'; // Remove border for normal state
        
        // Set progress color based on remaining tokens
        if(remaining === 0) {
          progressFill.style.background = '#ef4444'; // Red for empty
        } else if(remaining < 40) {
          progressFill.style.background = '#ef4444'; // Red for low
        } else if(remaining < 100) {
          progressFill.style.background = '#f59e0b'; // Yellow for medium
        } else {
          progressFill.style.background = '#22c55e'; // Green for good
        }
        
        progressText.textContent = remaining;
        console.log('Showing normal progress:', remaining, 'tokens remaining');
      }
    }
  }
  
  const getKey = () => {
    const activeKey = load('mxq_active_key') || 'main';
    return API_KEYS[activeKey] || API_KEYS.main;
  };
  
  const getActiveKeyName = () => {
    return load('mxq_active_key') || 'main';
  };
  const getModel = () => {
    // Force use of the working model for now
    return 'gemini-2.0-flash';
  };
  // --- Ontario G1‚Äì6 quick taxonomy (extend as needed) ---
  const ONTARIO = {
    subjects: {
      "Math": {
        strands: {
          "Number": ["counting & place value","addition/subtraction","multiplication/division (intro)","fractions (intro)"],
          "Patterning & Algebra": ["patterns","variables (gr. 5‚Äì6)"],
          "Measurement": ["length, mass, capacity","time, perimeter, area"],
          "Geometry & Spatial Sense": ["2D/3D shapes","location & movement"],
          "Data": ["collect/organize","read/interpret","probability (intro)"]
        }
      },
      "Language": {
        strands: {
          "Oral Communication": ["listening","speaking","presenting"],
          "Reading": ["comprehension","inferencing","vocabulary","text features"],
          "Writing": ["idea generation","draft/revise/edit","conventions"],
          "Media Literacy": ["purpose/audience","representation","techniques"]
        }
      },
      "Science": {
        strands: {
          "Life Systems": ["needs of living things","habitats","human body (gr.5‚Äì6)"],
          "Matter & Energy": ["properties of matter","energy forms","light & sound"],
          "Structures & Mechanisms": ["materials","forces & motion","simple machines"],
          "Earth & Space": ["daily/seasonal changes","soil/rocks","space (gr.6)"]
        }
      },
      "Social Studies": {
        strands: {
          "Heritage & Identity": ["local communities","early societies","indigenous perspectives"],
          "People & Environments": ["roles & responsibilities","resources & sustainability","global connections"]
        }
      },
      "Phys-Ed": { strands: { "Active Living": [], "Movement Skills": [], "Healthy Living": [] } },
      "Visual Arts": { strands: { "Creating/Presenting": [], "Reflecting/Responding": [] } },
      "Music": { strands: { "Elements": [], "Creating/Performing": [], "Responding": [] } },
      "Drama": { strands: { "Creating/Presenting": [], "Reflecting/Responding": [] } },
      "Dance": { strands: { "Creating/Presenting": [], "Reflecting/Responding": [] } },
      "General": { strands: { "Cross-Curricular": [] } }
    }
  };

  // Bloom's ‚Üí student-friendly verbs (Ontario tone)
  const BLOOMS_VERBS = {
    "Remember": ["list","identify","name","recall","label"],
    "Understand": ["describe","explain","summarize","retell","classify"],
    "Apply": ["use","solve","demonstrate","model","show how"],
    "Analyze": ["compare","contrast","sort","categorize","find patterns"],
    "Evaluate": ["choose & justify","defend","critique","decide with reasons"],
    "Create": ["design","invent","compose","plan","build"]
  };

  // Ontario Learning Skills ‚Üí prompt nudges
  const LEARNING_SKILL_NUDGES = {
    "Responsibility": "Include a self-check about meeting expectations respectfully and safely.",
    "Organization": "Include a step about planning materials/time and next steps.",
    "Independent Work": "Prompt for quiet think time and personal goal-setting.",
    "Collaboration": "Invite partner talk and turn-taking with accountable talk stems.",
    "Initiative": "Ask for a personal connection or an optional extension challenge.",
    "Self-Regulation": "Add a strategy check: What will you do if you feel stuck?"
  };

  // === SEL topics for Grades 1‚Äì6 (Second Step‚Äìstyle) ===
  const SEL_TOPICS = {
    domains: {
      "Skills for Learning": {
        g1_2: [
          "listening with attention",
          "focusing attention",
          "self-talk to stay on task",
          "being assertive"
        ],
        g3_4: [
          "ignoring distractions",
          "self-talk: multi-step direction",
          "goal steps and feedback",
          "asking for help"
        ],
        g5_6: [
          "planning and prioritizing",
          "sustained attention",
          "self-monitoring work",
          "advocating respectfully"
        ],
        promptNudge:
          "Include a quick routine (e.g., focus attention, self-talk, assertive voice) students can practice while answering."
      },

      "Empathy": {
        g1_2: [
          "identifying feelings",
          "same and different feelings",
          "showing care"
        ],
        g3_4: [
          "perspective-taking",
          "empathy in group work",
          "kind responses"
        ],
        g5_6: [
          "multiple perspectives in conflict",
          "empathy + boundaries",
          "inclusive language"
        ],
        promptNudge:
          "Invite students to notice feelings, perspectives, and caring actions connected to the task."
      },

      "Emotion Management": {
        g1_2: [
          "Calm-Down Steps",
          "strong feelings at school"
        ],
        g3_4: [
          "triggers & body signals",
          "Calm-Down Steps"
        ],
        g5_6: [
          "reframing thoughts",
          "plan to manage stress before tasks"
        ],
        promptNudge:
          "Add a quick Calm-Down routine before/after thinking, and a check-in about body clues."
      },

      "Problem Solving": {
        g1_2: [
          "Say, Think, Explore, Pick"
        ],
        g3_4: [
          "Say, Think, Explore, Pick",
          "brainstorm then choose"
        ],
        g5_6: [
          "Say, Think, Explore, Pick",
          "consider short- and long-term effects"
        ],
        promptNudge:
          "Have students use S-T-E-P (Say, Think, Explore, Pick) while solving the question."
      },

      "Bullying Prevention": {
        g1_2: [
          "recognize, report, refuse",
          "bystander to upstander"
        ],
        g3_4: [
          "reporting vs tattling",
          "safe upstander words"
        ],
        g5_6: [
          "digital citizenship & kindness",
          "supporting targets safely"
        ],
        promptNudge:
          "If relevant, include a safe upstander step and clarify when to get adult help."
      },

      "Growth Mindset": {
        g1_2: [
          "yet language",
          "small practice steps"
        ],
        g3_4: [
          "effort + strategy talk",
          "tracking progress"
        ],
        g5_6: [
          "reflecting on strategies",
          "setting and revising goals"
        ],
        promptNudge:
          "Add a brief reflection about effort, strategies, or a next step toward a goal."
      }
    }
  };

  const bloomsVerb=lv=>({remember:'show what you know',understand:'explain your thinking',apply:'use your skills',analyze:'compare or find a pattern',evaluate:'choose and justify',create:'plan or design'})[(lv||'apply').toLowerCase()]||'explain your thinking';

  // Helper functions for Ontario prompt builder
  function getFiltersFromDOM() {
    const gradeValue = document.getElementById('gradeInput')?.value;
    const subjectValue = document.getElementById('subjectInput')?.value;
    const bloomsValue = document.getElementById('bloomsInput')?.value;
    const learningSkillValue = document.getElementById('lsInput')?.value;
    const selValue = document.getElementById('selInput')?.value;
    
    return {
      grade: gradeValue === "-" ? "" : (gradeValue || ""),
      subject: subjectValue === "-" ? "" : (subjectValue || ""),
      blooms: bloomsValue === "-" ? "" : (bloomsValue || ""),
      learningSkill: learningSkillValue === "-" ? "" : (learningSkillValue || ""),
      sel: selValue === "-" ? "" : (selValue || ""),
      keywords: (document.getElementById('keywordInput')?.value || "").trim(),
      concise: !!document.getElementById('conciseToggle')?.checked
    };
  }

  function pickBloomsVerb(level) {
    if (!level || level === "-") {
      // Return a random verb from any level when no specific level is selected
      const allVerbs = Object.values(BLOOMS_VERBS).flat();
      return allVerbs[Math.floor(Math.random() * allVerbs.length)];
    }
    const list = BLOOMS_VERBS[level] || BLOOMS_VERBS["Understand"];
    return list[Math.floor(Math.random()*list.length)];
  }

  function pickSubjectStrand(subject) {
    if (!subject || subject === "-") {
      // Return cross-curricular when no specific subject is selected
      return {name: "Cross-Curricular", topic: ""};
    }
    const s = ONTARIO.subjects[subject]?.strands || ONTARIO.subjects["General"].strands;
    const keys = Object.keys(s);
    if (!keys.length) return {name:"Cross-Curricular", topic:""};
    const strand = keys[Math.floor(Math.random()*keys.length)];
    const topics = s[strand];
    const topic = topics.length ? topics[Math.floor(Math.random()*topics.length)] : "";
    return {name: strand, topic};
  }

  function selBandForGrade(gradeStr) {
    if (!gradeStr || gradeStr === "-") {
      // Default to middle grade band when no specific grade is selected
      return "g3_4";
    }
    const g = parseInt(String(gradeStr), 10);
    if (g <= 2) return "g1_2";
    if (g <= 4) return "g3_4";
    return "g5_6";
  }

  function getSelNudge(selValue) {
    if (!selValue || selValue === "-") return "";
    const [domain] = selValue.split(" ‚Äî ");
    const nudge = SEL_TOPICS.domains[domain]?.promptNudge || "";
    return `SEL focus: ${selValue}. ${nudge}`;
  }

  function populateSELDropDown() {
    const grade = document.getElementById('gradeInput')?.value;
    // If grade is "-", use a default grade for SEL band calculation
    const gradeForBand = (grade === "-" || !grade) ? "3" : grade;
    const band = selBandForGrade(gradeForBand);
    const sel = document.getElementById('selInput');
    if (!sel) return;

    // clear existing (keep the first placeholder option)
    sel.length = 1;

    Object.entries(SEL_TOPICS.domains).forEach(([domain, cfg]) => {
      // Add domain as a header option
      const domainOpt = document.createElement('option');
      domainOpt.value = "";
      domainOpt.textContent = domain;
      domainOpt.disabled = true;
      domainOpt.style.fontWeight = "bold";
      sel.appendChild(domainOpt);
      
      // Add topics without indentation
      (cfg[band] || []).forEach(topic => {
        const opt = document.createElement('option');
        opt.value = `${domain} ‚Äî ${topic}`;
        opt.textContent = topic;
        sel.appendChild(opt);
      });
    });
  }

  /**
   * Returns a single string you can send to your AI model.
   * It bakes in: Grade (Ontario), Subject & Strand, Bloom's, Learning Skill, and your keywords.
   */
  function buildOntarioPrompt() {
    const f = getFiltersFromDOM();
    
    // Handle empty filter values (when "-" is selected)
    const gradeText = f.grade ? `for Grade ${f.grade}` : "for any grade level";
    const subjectText = f.subject ? `aligned to Ontario ${f.subject}` : "aligned to any Ontario subject";
    const bloomsText = f.blooms ? `Bloom's "${f.blooms}"` : "any cognitive level";
    const verb = f.blooms ? pickBloomsVerb(f.blooms) : "explain your thinking";
    const strandInfo = f.subject ? pickSubjectStrand(f.subject) : {name: "Cross-Curricular", topic: ""};
    const {name: strand, topic} = strandInfo;
    const lsLine = f.learningSkill ? LEARNING_SKILL_NUDGES[f.learningSkill] : "";
    const keyLine = f.keywords ? `CRITICAL: The question MUST focus primarily on this keyword: ${f.keywords}. Do NOT mix it with unrelated concepts from previous questions. The question should be directly about ${f.keywords} and make logical sense.` : "";
    const selLine = getSelNudge(f.sel);
    const lengthRule = f.concise
      ? "Keep question ‚â§ 12 words; answers ‚â§ 4 words each."
      : "Keep question ‚â§ 15 words; answers ‚â§ 6 words each.";

    // A friendly, Ontario-aligned "system" style prompt for question generation
    const prompt = `
You are a helpful Ontario elementary teacher assistant.
Create ONE student-facing question ${subjectText} (Grades 1‚Äì6), ${gradeText}, strand: ${strand}${topic?` (topic: ${topic})`:""}.
Cognitive demand: ${bloomsText} ‚Äî use a student-friendly verb like "${verb}".
${keyLine}
${selLine}
Constraints:
- ${f.grade ? `Match Grade ${f.grade}` : 'Use age-appropriate'} reading level; use simple sentences and familiar vocabulary.
- Include any necessary everyday contexts culturally respectful to diverse Ontario classrooms.
- ${lengthRule}
- If the response mode is multiple-choice (your app handles this), ensure all options are plausible and only one is clearly best.
- Add a short "success criterion" in teacher voice: "I can ‚Ä¶" (one line).
- CRITICAL: Do NOT include answer choices (A, B, C, D) in the question text. The question should be a standalone prompt without any multiple choice options listed.
- Keep questions short and direct - focus on the core prompt without extra explanation.
- Do NOT reference previous lessons or activities (e.g., "continue your poster", "after the play we saw").

Learning Skills link: ${lsLine || "Optionally include a reflective mini-prompt about learning skills if it fits naturally."}

Output JSON:
{
  "question": "<short, direct question without answer choices - max 15 words>",
  "success_criterion": "I can ‚Ä¶",
  "teacher_note": "Why this fits Ontario Grade ${f.grade} (${f.subject}‚Äî${strand}${topic?`‚Äî${topic}`:""}; Bloom's: ${f.blooms})."
}
  `.trim();

    return prompt;
  }

  function buildPrompt({count,kw,grade,subject,ls,blooms,concise,mode}){
    // Use the new Ontario prompt builder
    const ontarioPrompt = buildOntarioPrompt();
    
    // Add the count and mode information to the existing prompt
    const isWyr = mode === 'wyr';
    const additionalConstraints = `
${isWyr ? 'FORMAT: Would You Rather (2 choices)' : ''}
- Provide EXACTLY ${count} choices. If ${count} is 3 or 4, the LAST choice MUST be "üìù Other (explain)".
- Choices should be broad strategies/frames that encourage critical thinking (not hyper-specific facts).
- DO NOT include backticks, markdown, explanations, or any fields other than "question" and "choices".
- CRITICAL: The question field should contain ONLY the question text, NOT the answer choices. Answer choices go in the "choices" array.
${isWyr ? '- For "Would You Rather" format: Start question with "Would you rather..." and provide exactly 2 contrasting choices' : ''}
`.trim();
    
    const prompt = ontarioPrompt + '\n\n' + additionalConstraints;
    
    console.log('Built Ontario prompt:', prompt);
    console.log('Current filters being used:', {kw, grade, subject, ls, blooms, concise});
    return prompt;
  }
  // Question validation function
  function validateGeneratedQuestion(obj) {
    if (!obj || typeof obj !== 'object') return false;
    
    // Check if question exists and is a string
    if (!obj.question || typeof obj.question !== 'string') return false;
    
    // Check if choices exist and is an array
    if (!obj.choices || !Array.isArray(obj.choices) || obj.choices.length < 2) return false;
    
    const question = obj.question.trim();
    const choices = obj.choices.map(c => c.trim()).filter(Boolean);
    
    // Validation checks
    const issues = [];
    
    // 1. Question should be standalone (not reference previous activities)
    const previousActivityPatterns = [
      /\b(?:this|that|the|your)\s+(?:activity|lesson|work|task|project|experiment|game|story|book|text|reading|video|discussion|conversation|group|partner|team)\b/i,
      /\b(?:continue|finish|complete|extend|build\s+on|add\s+to)\b/i,
      /\b(?:based\s+on|from\s+what|using\s+the|with\s+the)\b/i,
      /\b(?:what\s+you\s+learned|what\s+you\s+discovered|what\s+you\s+found)\b/i
    ];
    
    if (previousActivityPatterns.some(pattern => pattern.test(question))) {
      issues.push("Question references previous activities or assumes prior context");
    }
    
    // 2. Question should be clear and complete
    if (question.length < 10 || question.length > 100) {
      issues.push("Question is too short or too long");
    }
    
    if (!/[?]$/.test(question)) {
      issues.push("Question doesn't end with a question mark");
    }
    
    // 3. Question should relate to the choices provided
    const questionWords = question.toLowerCase().split(/\s+/).filter(word => word.length > 3);
    const choiceWords = choices.join(' ').toLowerCase().split(/\s+/).filter(word => word.length > 3);
    
    // Check if there's some thematic connection between question and choices
    const commonWords = questionWords.filter(word => choiceWords.includes(word));
    if (commonWords.length === 0 && questionWords.length > 0) {
      issues.push("Question and choices lack thematic connection");
    }
    
    // 4. Check if keywords are being used (if keywords were specified)
    const savedKeywords = load('mxq_keywords_active', '');
    if (savedKeywords && savedKeywords.trim()) {
      const keywordList = savedKeywords.toLowerCase().split(/[,\s]+/).filter(k => k.length > 2);
      const questionAndChoices = (question + ' ' + choices.join(' ')).toLowerCase();
      
      // Check if at least some keywords are present in the generated content
      const usedKeywords = keywordList.filter(keyword => questionAndChoices.includes(keyword));
      if (usedKeywords.length === 0) {
        issues.push(`Keywords not used: ${savedKeywords} - generated content should include these concepts`);
      } else if (usedKeywords.length < keywordList.length * 0.5) {
        // If less than 50% of keywords are used, warn but don't fail
        console.log(`Only ${usedKeywords.length}/${keywordList.length} keywords used: ${usedKeywords.join(', ')}`);
      }
      
      // 4b. Check for nonsensical keyword combinations
      if (keywordList.length > 1) {
        // Check if the question makes logical sense with multiple keywords
        const questionLower = question.toLowerCase();
        const hasUnrelatedKeywords = keywordList.some(keyword => {
          // Look for patterns where keywords are forced together without logical connection
          const forcedPatterns = [
            new RegExp(`\\b${keyword}\\b.*\\b(?:related to|about|with|and)\\b.*\\b(?!${keywordList.join('|')})\\w+`, 'i'),
            new RegExp(`\\b(?:related to|about|with|and)\\b.*\\b${keyword}\\b`, 'i')
          ];
          return forcedPatterns.some(pattern => pattern.test(questionLower));
        });
        
        if (hasUnrelatedKeywords) {
          issues.push("Question contains forced or unrelated keyword combinations that don't make logical sense");
        }
      }
      
      // 4c. Check for single keyword focus - question should primarily focus on the main keyword
      if (keywordList.length === 1) {
        const mainKeyword = keywordList[0];
        const questionLower = question.toLowerCase();
        
        // Check if the question is primarily about the keyword, not mixing with unrelated concepts
        const hasUnrelatedMixing = questionLower.includes(mainKeyword) && 
          (questionLower.includes('related to') || questionLower.includes('about') || questionLower.includes('with')) &&
          !questionLower.includes(mainKeyword + ' ') && !questionLower.includes(' ' + mainKeyword);
        
        if (hasUnrelatedMixing) {
          issues.push("Question mixes the keyword with unrelated concepts instead of focusing on it directly");
        }
        
        // 4d. Aggressive check for any words that aren't the current keyword or common words
        const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'up', 'down', 'out', 'off', 'over', 'under', 'through', 'during', 'before', 'after', 'above', 'below', 'between', 'among', 'inside', 'outside', 'near', 'far', 'here', 'there', 'this', 'that', 'these', 'those', 'what', 'how', 'which', 'why', 'when', 'where', 'who', 'can', 'will', 'should', 'would', 'could', 'may', 'might', 'must', 'shall', 'do', 'does', 'did', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'go', 'goes', 'went', 'gone', 'going', 'make', 'makes', 'made', 'making', 'get', 'gets', 'got', 'getting', 'know', 'knows', 'knew', 'knowing', 'think', 'thinks', 'thought', 'thinking', 'see', 'sees', 'saw', 'seeing', 'come', 'comes', 'came', 'coming', 'want', 'wants', 'wanted', 'wanting', 'look', 'looks', 'looked', 'looking', 'use', 'uses', 'used', 'using', 'find', 'finds', 'found', 'finding', 'give', 'gives', 'gave', 'giving', 'tell', 'tells', 'told', 'telling', 'work', 'works', 'worked', 'working', 'call', 'calls', 'called', 'calling', 'try', 'tries', 'tried', 'trying', 'ask', 'asks', 'asked', 'asking', 'need', 'needs', 'needed', 'needing', 'feel', 'feels', 'felt', 'feeling', 'become', 'becomes', 'became', 'becoming', 'leave', 'leaves', 'left', 'leaving', 'put', 'puts', 'put', 'putting', 'mean', 'means', 'meant', 'meaning', 'keep', 'keeps', 'kept', 'keeping', 'let', 'lets', 'let', 'letting', 'begin', 'begins', 'began', 'beginning', 'seem', 'seems', 'seemed', 'seeming', 'help', 'helps', 'helped', 'helping', 'talk', 'talks', 'talked', 'talking', 'turn', 'turns', 'turned', 'turning', 'start', 'starts', 'started', 'starting', 'show', 'shows', 'showed', 'showing', 'hear', 'hears', 'heard', 'hearing', 'play', 'plays', 'played', 'playing', 'run', 'runs', 'ran', 'running', 'move', 'moves', 'moved', 'moving', 'like', 'likes', 'liked', 'liking', 'live', 'lives', 'lived', 'living', 'stand', 'stands', 'stood', 'standing', 'sit', 'sits', 'sat', 'sitting', 'lie', 'lies', 'lay', 'lying', 'walk', 'walks', 'walked', 'walking', 'grow', 'grows', 'grew', 'growing', 'open', 'opens', 'opened', 'opening', 'close', 'closes', 'closed', 'closing', 'write', 'writes', 'wrote', 'writing', 'read', 'reads', 'read', 'reading', 'draw', 'draws', 'drew', 'drawing', 'sing', 'sings', 'sang', 'singing', 'dance', 'dances', 'danced', 'dancing', 'eat', 'drink', 'sleep', 'wake', 'wash', 'dress', 'brush', 'comb', 'tie', 'wear', 'carry', 'hold', 'catch', 'throw', 'kick', 'hit', 'push', 'pull', 'lift', 'drop', 'pick', 'cut', 'break', 'fix', 'build', 'clean', 'cook', 'bake', 'plant', 'water', 'feed', 'pet', 'ride', 'drive', 'fly', 'swim', 'climb', 'jump', 'hop', 'skip', 'bounce', 'roll', 'slide', 'swing', 'spin', 'twist', 'bend', 'stretch', 'reach', 'touch', 'feel', 'smell', 'taste', 'hear', 'see', 'look', 'watch', 'listen', 'speak', 'say', 'tell', 'ask', 'answer', 'question', 'explain', 'describe', 'name', 'label', 'count', 'add', 'subtract', 'multiply', 'divide', 'measure', 'weigh', 'compare', 'sort', 'group', 'match', 'find', 'solve', 'check', 'test', 'try', 'learn', 'study', 'practice', 'remember', 'forget', 'understand', 'know', 'think', 'believe', 'guess', 'wonder', 'imagine', 'create', 'make', 'build', 'design', 'draw', 'paint', 'color', 'write', 'read', 'tell', 'story', 'book', 'picture', 'game', 'toy', 'friend', 'family', 'home', 'school', 'class', 'teacher', 'student', 'help', 'share', 'care', 'love', 'happy', 'sad', 'angry', 'scared', 'excited', 'bored', 'tired', 'hungry', 'thirsty', 'hot', 'cold', 'big', 'small', 'long', 'short', 'tall', 'short', 'wide', 'narrow', 'thick', 'thin', 'heavy', 'light', 'fast', 'slow', 'loud', 'quiet', 'bright', 'dark', 'new', 'old', 'young', 'good', 'bad', 'nice', 'mean', 'kind', 'rude', 'polite', 'clean', 'dirty', 'neat', 'messy', 'easy', 'hard', 'simple', 'complicated', 'same', 'different', 'similar', 'opposite', 'first', 'last', 'next', 'before', 'after', 'begin', 'end', 'start', 'finish', 'open', 'close', 'on', 'off', 'yes', 'no', 'maybe', 'sure', 'okay', 'fine', 'great', 'awesome', 'terrible', 'wonderful', 'horrible', 'beautiful', 'ugly', 'fun', 'boring', 'interesting', 'exciting', 'calm', 'wild', 'safe', 'dangerous', 'strong', 'weak', 'healthy', 'sick', 'well', 'ill', 'happy', 'sad', 'angry', 'calm', 'nervous', 'confident', 'shy', 'brave', 'scared', 'smart', 'silly', 'serious', 'funny', 'quiet', 'loud', 'gentle', 'rough', 'careful', 'careless', 'patient', 'impatient', 'kind', 'mean', 'friendly', 'unfriendly', 'helpful', 'unhelpful', 'polite', 'rude', 'honest', 'dishonest', 'fair', 'unfair', 'responsible', 'irresponsible', 'organized', 'disorganized', 'neat', 'messy', 'clean', 'dirty', 'tidy', 'untidy', 'careful', 'careless', 'patient', 'impatient', 'brave', 'cowardly', 'strong', 'weak', 'healthy', 'sick', 'well', 'ill', 'happy', 'sad', 'angry', 'calm', 'nervous', 'confident', 'shy', 'brave', 'scared', 'smart', 'silly', 'serious', 'funny', 'quiet', 'loud', 'gentle', 'rough', 'careful', 'careless', 'patient', 'impatient', 'kind', 'mean', 'friendly', 'unfriendly', 'helpful', 'unhelpful', 'polite', 'rude', 'honest', 'dishonest', 'fair', 'unfair', 'responsible', 'irresponsible', 'organized', 'disorganized', 'neat', 'messy', 'clean', 'dirty', 'tidy', 'untidy', 'careful', 'careless', 'patient', 'impatient', 'brave', 'cowardly', 'strong', 'weak', 'healthy', 'sick', 'well', 'ill', 'happy', 'sad', 'angry', 'calm', 'nervous', 'confident', 'shy', 'brave', 'scared', 'smart', 'silly', 'serious', 'funny', 'quiet', 'loud', 'gentle', 'rough', 'careful', 'careless', 'patient', 'impatient', 'kind', 'mean', 'friendly', 'unfriendly', 'helpful', 'unhelpful', 'polite', 'rude', 'honest', 'dishonest', 'fair', 'unfair', 'responsible', 'irresponsible', 'organized', 'disorganized', 'neat', 'messy', 'clean', 'dirty', 'tidy', 'untidy', 'careful', 'careless', 'patient', 'impatient', 'brave', 'cowardly'];
        
        const questionWords = questionLower.split(/\s+/).filter(word => word.length > 2);
        const nonKeywordWords = questionWords.filter(word => 
          !commonWords.includes(word.toLowerCase()) && 
          word.toLowerCase() !== mainKeyword.toLowerCase() &&
          !word.toLowerCase().includes(mainKeyword.toLowerCase()) &&
          !mainKeyword.toLowerCase().includes(word.toLowerCase())
        );
        
        if (nonKeywordWords.length > 0) {
          console.log('Non-keyword words detected:', nonKeywordWords);
          issues.push(`Question contains words not related to current keyword: ${nonKeywordWords.join(', ')}`);
        }
      }
    }
    
    // 4e. Disallow references that assume prior work or events
    const assumePatterns = [
      /\b(yesterday|last\s+(?:week|lesson|class))\b/i,
      /\b(the\s+(?:play|experiment|field\s*trip)\s+we\s+(?:did|saw|finished))\b/i,
      /\b(continue|finish|complete|build\s+on|add\s+to)\s+(?:your|the)\b/i
    ];
    if(assumePatterns.some(p=>p.test(question))) {
      issues.push("Question assumes prior activity/session");
    }
    
    // 4f. Ensure question does not contain answer choices
    const choiceLike = /\b(?:A\)|B\)|C\)|D\))|(?:Option\s+[ABCD])\b/i;
    if(choiceLike.test(question)) {
      issues.push("Question text includes answer choices");
    }
    
    // 4g. Ensure choice count matches response mode
    const expectedCount = (()=> {
      const saved = load('mxq_choices')||{};
      const modeSel = saved.mode || '4';
      if(modeSel==='open') return 1;
      if(modeSel==='wyr')  return 2;
      return parseInt(modeSel,10)||4;
    })();
    if(Array.isArray(choices) && choices.length !== expectedCount && expectedCount !== 1){
      issues.push(`Choices length ${choices.length} does not match expected ${expectedCount}`);
    }
    
    // 5. Choices should be distinct and meaningful
    if (choices.length !== new Set(choices).size) {
      issues.push("Choices are not unique");
    }
    
    const veryShortChoices = choices.filter(c => c.length < 3);
    if (veryShortChoices.length > 0) {
      issues.push("Some choices are too short to be meaningful");
    }
    
    // 6. Question should be age-appropriate and clear
    const complexPatterns = [
      /\b(?:notwithstanding|furthermore|consequently|subsequently)\b/i,
      /\b(?:hypothesis|methodology|quantitative|qualitative)\b/i
    ];
    
    if (complexPatterns.some(pattern => pattern.test(question))) {
      issues.push("Question uses language that may be too complex for the grade level");
    }
    
    // Return validation result
    if (issues.length > 0) {
      console.log('Question validation failed:', issues);
      return { valid: false, issues };
    }
    
    return { valid: true };
  }

  // Question repair function - tries to fix AI-generated content to make it standalone
  function repairGeneratedQuestion(obj) {
    if (!obj || !obj.question || !obj.choices) return null;
    
    console.log('Attempting to repair question:', obj.question);
    
    let question = obj.question.trim();
    let choices = obj.choices.map(c => c.trim()).filter(Boolean);
    
    // 0. Strip any embedded choices from question like "A) ..., B) ..."
    question = question.replace(/\b(?:A\)|B\)|C\)|D\))\s*[^?]*\??/gi,'').trim();
    
    // 0a. Check if keywords are missing and try to incorporate them
    const savedKeywords = load('mxq_keywords_active', '');
    if (savedKeywords && savedKeywords.trim()) {
      const keywordList = savedKeywords.toLowerCase().split(/[,\s]+/).filter(k => k.length > 2);
      const questionAndChoices = (question + ' ' + choices.join(' ')).toLowerCase();
      const missingKeywords = keywordList.filter(keyword => !questionAndChoices.includes(keyword));
      
      if (missingKeywords.length > 0) {
        console.log('Missing keywords detected:', missingKeywords);
        // Try to incorporate missing keywords into the question - but only the current keyword
        const currentKeyword = missingKeywords[0];
        
        // Clean up any forced "related to" or "about" phrases that don't make sense
        question = question.replace(/\s+(?:related to|about|with)\s+\w+\s*\?$/, '?');
        
        // Now add the current keyword in a logical way
        if (question.toLowerCase().includes('how') || question.toLowerCase().includes('what')) {
          // For "how" or "what" questions, make it about the keyword
          question = question.replace(/\?$/, ` about ${currentKeyword}?`);
        } else if (question.toLowerCase().includes('which')) {
          // For "which" questions, make it about the keyword
          question = question.replace(/\?$/, ` for ${currentKeyword}?`);
        } else {
          // For other question types, add the keyword naturally
          question = question.replace(/\?$/, ` about ${currentKeyword}?`);
        }
      }
    }
    
    // 0b. Remove prior-activity assumptions
    question = question
      .replace(/\b(?:yesterday|last\s+(?:week|lesson|class))\b.*?\?/i, '?')
      .replace(/\bthe\s+(?:play|experiment|field\s*trip)\s+we\s+(?:did|saw|finished)\b.*?\?/i, '?')
      .replace(/\b(?:continue|finish|complete|build\s+on|add\s+to)\s+(?:your|the)\b.*?\?/i, '?')
      .replace(/\s+/g,' ').replace(/\s\?/g,'?').trim();
    
    // 0c. Enforce "simple yet deep" phrasing: prefer short, direct stems
    if(question.split(' ').length > 15){
      // keep first ~14‚Äì15 words, end cleanly
      const trimmed = question.replace(/\s+/g,' ').split(' ').slice(0,15).join(' ');
      question = /[?.!]$/.test(trimmed) ? trimmed : (trimmed + '?');
    }
    
    // 0d. Ensure choices match mode
    const saved = load('mxq_choices')||{};
    const modeSel = saved.mode || '4';
    const need = (modeSel==='open') ? 1 : (modeSel==='wyr' ? 2 : parseInt(modeSel,10)||4);
    if(need === 1){
      choices = ['üìù Your response']; // open response placeholder
    } else {
      // de-dup, keep concise, ensure "üìù Other (explain)" is present for 3/4
      choices = Array.from(new Set(choices.map(c=>c.replace(/\s+/g,' ').trim()).filter(Boolean)));
      if((need===3 || need===4) && !choices.some(c=>/^üìù\s*Other/i.test(c))){
        choices = choices.slice(0, need-1).concat(['üìù Other (explain)']);
      }
      if(choices.length !== need){
        // pad with generic but age-appropriate frames
        const pads = ['Try a different way','Ask a partner','Use a tool','Check an example'];
        while(choices.length < need) choices.push(pads[choices.length % pads.length]);
        choices = choices.slice(0,need);
      }
    }
    
    // 0e. Final clean-up for age-appropriateness (remove complex academic words)
    const tooComplex = /\b(?:notwithstanding|furthermore|consequently|subsequently|hypothesis|methodology|quantitative|qualitative)\b/ig;
    question = question.replace(tooComplex,'').replace(/\s+/g,' ').replace(/\s\?/,'?').trim();
    
    // 1. Fix questions that reference previous activities
    const repairPatterns = [
      // Fix "continue working on..." ‚Üí "How will you approach..."
      {
        pattern: /\b(?:continue|finish|complete|extend|build\s+on|add\s+to)\s+(?:working\s+on|your\s+work|the\s+task|this\s+project)\b/gi,
        replacement: 'How will you approach'
      },
      // Fix "based on what you learned..." ‚Üí "What strategy will you use..."
      {
        pattern: /\b(?:based\s+on|from\s+what)\s+(?:you\s+learned|you\s+discovered|you\s+found)\b/gi,
        replacement: 'What strategy will you use'
      },
      // Fix "using the text/story/book..." ‚Üí "How can you..."
      {
        pattern: /\b(?:using|with|from)\s+(?:the|your)\s+(?:text|story|book|reading|video|discussion)\b/gi,
        replacement: 'How can you'
      },
      // Fix "what you learned in..." ‚Üí "what you know about..."
      {
        pattern: /\b(?:what\s+you\s+learned|what\s+you\s+discovered)\s+(?:in|from|about)\b/gi,
        replacement: 'what you know about'
      },
      // Fix "this activity/task/project" ‚Üí "this learning situation"
      {
        pattern: /\b(?:this|that|the|your)\s+(?:activity|lesson|work|task|project|experiment|game)\b/gi,
        replacement: 'this learning situation'
      }
    ];
    
    // Apply repair patterns
    repairPatterns.forEach(({pattern, replacement}) => {
      question = question.replace(pattern, replacement);
    });
    
    // 2. Ensure question ends with question mark
    if (!/[?]$/.test(question)) {
      question = question.replace(/[.!]$/, '?');
      if (!/[?]$/.test(question)) {
        question += '?';
      }
    }
    
    // 3. Fix overly complex language
    const complexWordReplacements = {
      'notwithstanding': 'even though',
      'furthermore': 'also',
      'consequently': 'so',
      'subsequently': 'then',
      'hypothesis': 'prediction',
      'methodology': 'method',
      'quantitative': 'measurable',
      'qualitative': 'descriptive'
    };
    
    Object.entries(complexWordReplacements).forEach(([complex, simple]) => {
      const regex = new RegExp(`\\b${complex}\\b`, 'gi');
      question = question.replace(regex, simple);
    });
    
    // 4. Ensure question is complete and clear
    if (question.length < 10) {
      question = 'How can you ' + question.replace(/^how\s+/i, '').replace(/^what\s+/i, 'show what you know about ');
    }
    
    // 5. Fix choices to ensure they're meaningful
    choices = choices.map(choice => {
      if (choice.length < 3) {
        return choice + ' (explain)';
      }
      return choice;
    });
    
    // 6. Ensure choices are unique
    const uniqueChoices = [];
    const seen = new Set();
    choices.forEach(choice => {
      const cleanChoice = choice.toLowerCase().replace(/[^\w\s]/g, '').trim();
      if (!seen.has(cleanChoice)) {
        seen.add(cleanChoice);
        uniqueChoices.push(choice);
      }
    });
    
    // Ensure we have at least 2 choices
    while (uniqueChoices.length < 2) {
      uniqueChoices.push('Other (explain)');
    }
    
    const repaired = {
      question: question,
      choices: uniqueChoices,
      wasRepaired: true,
      originalQuestion: obj.question
    };
    
    console.log('Question repaired from:', obj.question);
    console.log('Question repaired to:', question);
    
    return repaired;
  }

  function parseJSONLenient(txt){
    if(!txt) return null;
    let cleaned = txt.replace(/```[\s\S]*?```/g, m => m.replace(/```(?:json)?/gi,'').replace(/```/g,'')).replace(/```(?:json)?/gi,'').replace(/```/g,'').trim();
    try { return JSON.parse(cleaned); } catch {}
    const m = cleaned.match(/\{[\s\S]*\}/);
    if(m){ try { return JSON.parse(m[0]); } catch {} }
    return null;
  }
  function addEmojisUnique(arr){
    const pool=["ü§ù","üé≤","üìñ","üîÑ","üé®","‚òÄÔ∏è","üë´","üèÉ","üéµ","üé≠","üçé","üåé","üß©","‚úèÔ∏è","üñåÔ∏è","‚öΩ","üé∂","ü¶ã","üöÄ","ü™¥","üïäÔ∏è","üîç","üß†","üí°","üõ†Ô∏è","üó∫Ô∏è","üß™","üìê","üßÆ","üó£Ô∏è","üìù"];
    const hints=[[/(read|story|book|text)/i,"üìñ"],[/(friend|kind|include|help)/i,"ü§ù"],[/(music|song|rhythm)/i,"üéµ"],[/(art|draw|paint|colour|color)/i,"üé®"],[/(move|exercise|run|sport)/i,"üèÉ"],[/(pattern|sequence)/i,"üîÑ"],[/(science|experiment|observe)/i,"üß™"],[/(map|timeline|community)/i,"üó∫Ô∏è"],[/(math|count|shape|measure)/i,"üßÆ"]];
    const used=new Set();
    return arr.map((c)=>{
      if(/other/i.test(c)) return "üìù "+c.replace(/^üìù\s*/i,'');
      let emo=""; for(const [re,e] of hints){ if(re.test(c)&&!used.has(e)){ emo=e; break; } }
      if(!emo){ emo = pool.find(e=>!used.has(e)&&e!=="üìù") || "üéØ"; }
      used.add(emo); return `${emo} ${String(c).replace(/^[^\w\d]+/,'').trim()}`;
    });
  }
  function postConcise(obj, concise){
    if(!concise) return obj;
    const shortQ = obj.question.replace(/\s+/g,' ').split(' ').slice(0,7).join(' ');
    const shortC = obj.choices.map(c=>c.replace(/\s+/g,' ').split(' ').slice(0,4).join(' '));
    return {question:shortQ.trim(), choices:shortC};
  }
  async function geminiQ({count,kw,grade,subject,ls,blooms,concise}){
    const key=getKey();
    if(!key) throw new Error('No API key');
    
    console.log('geminiQ called with:', {count, kw, grade, subject, ls, blooms, concise});
    console.log('Using key length:', key.length);
    
    // Get the current mode for the prompt
    const modeSel = getSelectedResponseMode();
    console.log('modeSel value:', modeSel);
    
    // Use only the working model
    const modelsToTry = ['gemini-2.0-flash'];
    let obj0 = null; // Declare obj0 outside the loop
    let currentModel = 'gemini-2.0-flash'; // Track the current model
    
    for(const tryModel of modelsToTry) {
      currentModel = tryModel; // Update the current model
      try {
        console.log('Trying model:', tryModel);
        console.log('About to call buildPrompt with modeSel:', modeSel);
        const url=`https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(tryModel)}:generateContent?key=${encodeURIComponent(key)}`;
        const prompt=buildPrompt({count,kw,grade,subject,ls,blooms,concise,mode:modeSel});
        
        console.log('Making request to:', url);
        const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({contents:[{role:'user',parts:[{text:prompt}]}]})});
        console.log('Response status:', res.status);
        
        if(res.status === 429) {
          console.log(`Rate limit hit for model ${tryModel}, trying next model...`);
          console.log('Rate limit detected - this model has reached its quota');
          localStorage.setItem('mxq_last_ai_error', `Daily quota exceeded (200 requests). Resets at midnight Pacific Time.`);
          localStorage.setItem('mxq_last_failed_key', getActiveKeyName());
          updateAIWarning('Daily Quota Exceeded - Resets Tomorrow', true);
          // Clear the AI status to show it's not working
          localStorage.removeItem('mxq_ai_status');
          
          // Try auto-switching to backup key
          console.log('Attempting auto-switch to backup key...');
          const switchResult = await autoSwitchToBackup();
          if(switchResult) {
            console.log('Auto-switch successful, retrying with new key...');
            // Retry the request with the new key
            const newKey = getKey();
            const newUrl = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(tryModel)}:generateContent?key=${encodeURIComponent(newKey)}`;
            const newRes = await fetch(newUrl, {method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({contents: [{role: 'user', parts: [{text: prompt}]}]})});
            
            if(newRes.ok) {
              const newData = await newRes.json();
              const newTxt = (newData?.candidates?.[0]?.content?.parts || []).map(p => p.text || '').join(' ').trim();
              obj0 = parseJSONLenient(newTxt);
              if(obj0 && Array.isArray(obj0.choices)) {
                console.log('Success with auto-switched key');
                incrementTokenUsage(getActiveKeyName());
                break;
              }
            }
          }
          
          continue; // Try next model
        } else if(res.status === 403) {
          console.log('Invalid API key, trying next model...');
          console.log('403 error - API key may be invalid or quota exceeded');
          localStorage.setItem('mxq_last_ai_error', `403 error for ${tryModel}`);
          updateAIWarning('Invalid API Key', true);
          // Clear the AI status to show it's not working
          localStorage.removeItem('mxq_ai_status');
          continue; // Try next model
        } else if(!res.ok) {
          console.log(`HTTP error ${res.status} for model ${tryModel}, trying next model...`);
          console.log(`HTTP ${res.status} error - model may be unavailable`);
          localStorage.setItem('mxq_last_ai_error', `HTTP ${res.status} error for ${tryModel}`);
          updateAIWarning(`HTTP Error ${res.status}`, true);
          // Clear the AI status to show it's not working
          localStorage.removeItem('mxq_ai_status');
          continue; // Try next model
        }
        const data=await res.json();
        console.log('Response data:', data);
        const txt=(data?.candidates?.[0]?.content?.parts||[]).map(p=>p.text||'').join(' ').trim();
        console.log('Extracted text:', txt);
        console.log('Raw AI response:', txt);
        localStorage.setItem('mxq_ai_raw', txt);
        obj0=parseJSONLenient(txt); // Assign to the outer variable
        console.log('Parsed object:', obj0);
        console.log('Keywords being validated against:', load('mxq_keywords', ''));
        if(!obj0 || !Array.isArray(obj0.choices)) throw new Error('Bad AI JSON - missing or invalid choices array');
        
        // Validate the generated question
        const validation = validateGeneratedQuestion(obj0);
        if (!validation.valid) {
          console.log('Generated content failed validation:', validation.issues);
          
          // Try to repair the question before giving up
          const repaired = repairGeneratedQuestion(obj0);
          if (repaired && validateGeneratedQuestion(repaired).valid) {
            console.log('Question successfully repaired and validated');
            obj0 = repaired; // Use the repaired version
          } else {
            console.log('Question repair failed, trying next model');
            
            // If this is the last model to try, throw an error to trigger fallback
            if (tryModel === modelsToTry[modelsToTry.length - 1]) {
              throw new Error(`AI generation failed validation and repair: ${validation.issues.join(', ')}`);
            }
            
            // Try next model
            continue;
          }
        }
        
        // If we get here, the request was successful and validated (either original or repaired)
        console.log('Success with model:', tryModel, '- content validated' + (obj0.wasRepaired ? ' (repaired)' : ''));
        
        // Increment token usage for successful generation
        incrementTokenUsage(getActiveKeyName());
        
        break;
      } catch(e) {
        console.log('Error with model', tryModel, ':', e.message);
        if(tryModel === modelsToTry[modelsToTry.length - 1]) {
          // This was the last model to try
          throw e;
        }
        // Try next model
        continue;
      }
    }

    // normalize choices + emojis + policy for Other
    const want=count;
    const nonOther=obj0.choices.filter(Boolean).filter(c=>!(/other/i.test(c)));
    if(want>=3){
      while(nonOther.length<want-1) nonOther.push('Share another idea');
      obj0.choices=addEmojisUnique(nonOther.slice(0,want-1).concat('Other (explain)'));
    } else {
      while(nonOther.length<2) nonOther.push('Share another idea');
      obj0.choices=addEmojisUnique(nonOther.slice(0,2));
    }

    const obj = postConcise(obj0, concise);

    if(typeof obj.question!=='string' || !obj.question.trim()){
      const verb=({Remember:'show what you know',Understand:'explain your thinking',Apply:'use your skills',Analyze:'compare or find a pattern',Evaluate:'choose and justify',Create:'plan or design'}[blooms]||'explain your thinking');
      obj.question = (kw?`How will you ${verb} about ${kw} today?`:(subject!=='General'?`How will you ${verb} in ${subject} today?`:`What is one smart way you can ${verb} today?`));
      localStorage.setItem('mxq_ai_lastgen', JSON.stringify({used:'gemini',questionSource:'fallback',time:Date.now(),model:currentModel}));
    } else {
      localStorage.setItem('mxq_ai_lastgen', JSON.stringify({used:'gemini',questionSource:'model',time:Date.now(),model:currentModel}));
    }
    return obj;
  }
  
  // API key switcher functions
  function switchToKey(keyName) {
    save('mxq_active_key', keyName);
    localStorage.removeItem('mxq_ai_status'); // Clear status to force retest
    localStorage.removeItem('mxq_last_failed_key'); // Clear failed key tracking
    toast(`Switched to ${keyName} API key`);
    aiStatus();
    updateKeyButtons();
    updateTokenProgress();
  }

  // Auto-switch to backup key if current key fails
  async function autoSwitchToBackup() {
    const currentKey = getActiveKeyName();
    const keys = ['main', 'BU1', 'BU2'];
    const currentIndex = keys.indexOf(currentKey);
    
    // Try next key in sequence
    for(let i = 1; i <= 2; i++) {
      const nextIndex = (currentIndex + i) % 3;
      const nextKey = keys[nextIndex];
      
      console.log(`Auto-switching: trying ${nextKey} (was ${currentKey})`);
      
      // Test the next key
      const testResult = await testSpecificKey(nextKey);
      if(testResult) {
        console.log(`Auto-switch successful: ${nextKey} is working`);
        switchToKey(nextKey);
        return true;
      }
    }
    
    console.log('Auto-switch failed: no working keys found');
    return false;
  }

  // Test a specific key without switching to it
  async function testSpecificKey(keyName) {
    const originalKey = getActiveKeyName();
    save('mxq_active_key', keyName);
    
    try {
      const key = getKey();
      const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${key}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: 'test' }] }]
        })
      });
      
      const success = res.ok;
      
      // Restore original key
      save('mxq_active_key', originalKey);
      
      return success;
    } catch(e) {
      // Restore original key
      save('mxq_active_key', originalKey);
      return false;
    }
  }
  
  function updateKeyButtons() {
    const activeKey = getActiveKeyName();
    console.log('updateKeyButtons called - active key:', activeKey);
    console.log('localStorage mxq_active_key:', load('mxq_active_key'));
    
    // Update button styles
    const mainBtn = document.getElementById('keyMain');
    const bu1Btn = document.getElementById('keyBU1');
    const bu2Btn = document.getElementById('keyBU2');
    
    console.log('Found buttons:', {mainBtn: !!mainBtn, bu1Btn: !!bu1Btn, bu2Btn: !!bu2Btn});
    
    if(mainBtn) {
      const isMainActive = activeKey === 'main';
      mainBtn.style.background = isMainActive ? '#22c55e' : '#6b7280';
      mainBtn.style.color = isMainActive ? 'white' : '#d1d5db';
      mainBtn.style.border = isMainActive ? '2px solid #16a34a' : 'none';
      console.log('Main button:', isMainActive ? 'GREEN' : 'GRAY', 'activeKey:', activeKey, 'isMainActive:', isMainActive);
    }
    if(bu1Btn) {
      const isBU1Active = activeKey === 'BU1';
      bu1Btn.style.background = isBU1Active ? '#22c55e' : '#6b7280';
      bu1Btn.style.color = isBU1Active ? 'white' : '#d1d5db';
      bu1Btn.style.border = isBU1Active ? '2px solid #16a34a' : 'none';
      console.log('BU1 button:', isBU1Active ? 'GREEN' : 'GRAY', 'activeKey:', activeKey, 'isBU1Active:', isBU1Active);
    }
    if(bu2Btn) {
      const isBU2Active = activeKey === 'BU2';
      bu2Btn.style.background = isBU2Active ? '#22c55e' : '#6b7280';
      bu2Btn.style.color = isBU2Active ? 'white' : '#d1d5db';
      bu2Btn.style.border = isBU2Active ? '2px solid #16a34a' : 'none';
      console.log('BU2 button:', isBU2Active ? 'GREEN' : 'GRAY', 'activeKey:', activeKey, 'isBU2Active:', isBU2Active);
    }
  }
  
  function updateQuickSwitchButtons() {
    const currentModel = load('mxq_ai_model') || 'gemini-2.0-flash';
    console.log('Updating Quick Switch buttons, current model:', currentModel);
    
    // Update Quick Switch button styles
    const flash2Btn = document.getElementById('model2Flash');
    const flash1Btn = document.getElementById('model1Flash');
    const pro1Btn = document.getElementById('model1Pro');
    
    if(flash2Btn) {
      flash2Btn.style.background = currentModel === 'gemini-2.0-flash' ? '#6b7280' : '#374151';
      flash2Btn.style.color = currentModel === 'gemini-2.0-flash' ? 'white' : '#9ca3af';
      console.log('2.0 Flash button:', currentModel === 'gemini-2.0-flash' ? 'ACTIVE' : 'INACTIVE');
    }
    if(flash1Btn) {
      flash1Btn.style.background = currentModel === 'gemini-1.5-flash' ? '#6b7280' : '#374151';
      flash1Btn.style.color = currentModel === 'gemini-1.5-flash' ? 'white' : '#9ca3af';
      console.log('1.5 Flash button:', currentModel === 'gemini-1.5-flash' ? 'ACTIVE' : 'INACTIVE');
    }
    if(pro1Btn) {
      pro1Btn.style.background = currentModel === 'gemini-1.5-pro' ? '#6b7280' : '#374151';
      pro1Btn.style.color = currentModel === 'gemini-1.5-pro' ? 'white' : '#9ca3af';
      console.log('1.5 Pro button:', currentModel === 'gemini-1.5-pro' ? 'ACTIVE' : 'INACTIVE');
    }
  }
  
  // Comprehensive offline question bank with usage tracking
  function offlineQ(count, subject, ls, concise) {
    // Get or initialize the used questions tracking
    let usedQuestions = JSON.parse(localStorage.getItem('mxq_used_questions') || '{}');
    
    // Define the comprehensive question bank
    const questionBank = {
      open: [
        'What is something kind you can do for a friend today?',
        'How do you show respect to your teacher?',
        'What do you do when a task feels too hard?',
        'What is one thing that makes you feel proud of yourself?',
        'How can you help someone who is feeling sad?',
        'What makes a person a good friend?',
        'How can you make our classroom a better place?',
        'What do you do when you make a mistake?',
        'What is something new you want to learn this week?',
        'How can you show honesty in school?',
        'What helps you calm down when you feel upset?',
        'What do you do when you feel nervous about something?',
        'What is your favorite way to share ideas with others?',
        'What is something that makes learning fun for you?',
        'How can you show fairness during a game?',
        'What is something you can teach to another student?',
        'How do you show that you are a good listener?',
        'What is one way you can be a leader in class?',
        'What makes you feel safe at school?',
        'What is one question you are curious about today?',
        'How do you know when you should ask for help?',
        'What makes you laugh the most?',
        'How do you take care of your body every day?',
        'What is one way you can make someone feel welcome?',
        'What is your favorite part of the school day?',
        'How do you celebrate when you achieve a goal?',
        'What is something you want to get better at?',
        'What do you do when you feel stuck on a problem?',
        'How do you encourage a classmate who is trying hard?',
        'What is one thing you are thankful for?',
        'How can you show responsibility in the classroom?',
        'What makes you feel included in a group?',
        'What is one goal you have for yourself this month?',
        'How do you take care of the classroom materials?',
        'What makes you excited to learn?',
        'What is one way to show teamwork in sports?',
        'How do you show respect to your family?',
        'What is your favorite way to solve problems?',
        'What makes you feel calm inside?',
        'How do you show kindness without using words?',
        'What is something you learned this week?',
        'What is one rule that is important to follow?',
        'How do you help someone who is new to school?',
        'What makes you different in a good way?',
        'What is something you wonder about the world?',
        'How do you show that you are ready to learn?',
        'What is one way you can improve as a student?',
        'What is something you enjoy doing with your friends?',
        'How do you know when you are being fair?',
        'What is something you can do to make tomorrow a good day?'
      ],
      '2': [
        'Is it better to work by yourself or with a partner?',
        'Do you prefer asking questions or answering them?',
        'Is it easier to start a project or finish it?',
        'Do you like playing outside more than playing inside?',
        'Is it better to be fast or to be careful?',
        'Do you prefer reading books or listening to stories?',
        'Is it easier to tell the truth or to tell a story?',
        'Do you like helping others more than being helped?',
        'Is it better to lead a group or to follow directions?',
        'Do you prefer writing with a pencil or drawing with crayons?',
        'Is it better to try again or to give up?',
        'Do you like math more than reading?',
        'Is it easier to plan what to do or to do it right away?',
        'Do you prefer listening quietly or talking with friends?',
        'Is it better to share first or to wait your turn?',
        'Do you like solving puzzles more than telling stories?',
        'Is it easier to be brave or to be kind?',
        'Do you prefer working in the morning or in the afternoon?',
        'Is it better to listen to instructions or to figure things out yourself?',
        'Do you like numbers more than letters?',
        'Is it easier to imagine new things or to remember old ones?',
        'Do you prefer helping a friend or asking a friend for help?',
        'Is it better to be fair or to be first in line?',
        'Do you like games more than reading?',
        'Is it easier to stay quiet or to keep moving?',
        'Do you prefer making choices or having someone decide for you?',
        'Is it better to be quick or to be thoughtful?',
        'Do you like drawing pictures more than writing sentences?',
        'Is it easier to follow rules or to make rules?',
        'Do you prefer learning indoors or outdoors?',
        'Is it better to play in a group or to play alone?',
        'Do you like working on art more than working on science?',
        'Is it easier to be a leader or a helper?',
        'Do you prefer building something new or fixing something broken?',
        'Is it better to tell a joke or to hear a joke?',
        'Do you like telling stories more than listening to them?',
        'Is it easier to think quietly or to share your ideas aloud?',
        'Do you prefer playing soccer or basketball?',
        'Is it better to keep trying or to take a break?',
        'Do you like morning recess more than afternoon recess?',
        'Is it easier to start homework or to finish it?',
        'Do you prefer learning with a partner or with a group?',
        'Is it better to work quietly or with music?',
        'Do you like science more than art?',
        'Is it easier to give advice or to take advice?',
        'Do you prefer reading facts or reading stories?',
        'Is it better to listen first or to talk first?',
        'Do you like using computers more than using books?',
        'Is it easier to play by the rules or to make up new ones?',
        'Do you prefer learning by reading or by doing?'
      ],
      '3': [
        'What is the best way to calm down?',
        'How can you solve a problem with a friend?',
        'What helps you learn best?',
        'What do you do when you make a mistake?',
        'What is the most important part of being a good friend?',
        'How can you show respect?',
        'What helps you focus in class?',
        'What is the best way to celebrate success?',
        'How do you show responsibility?',
        'What makes a team strong?',
        'What helps you feel safe?',
        'What is the best way to show honesty?',
        'What helps you get ready for school?',
        'How do you share with others?',
        'What makes you feel proud?',
        'What helps you calm down?',
        'What is the best way to be fair?',
        'What helps you remember?',
        'What is the best way to welcome someone new?',
        'What helps you when you feel sad?',
        'How do you show teamwork?',
        'What helps you grow as a learner?',
        'What is the best way to be safe outside?',
        'What helps you solve math problems?',
        'How do you care for nature?',
        'What helps you be creative?',
        'How do you show kindness?',
        'What helps you learn reading?',
        'How do you show fairness?',
        'What is the best way to learn more?',
        'How do you solve puzzles?',
        'What makes learning fun?',
        'How do you show care for family?',
        'What helps you when you feel stuck?',
        'What helps you feel proud of your work?',
        'How do you show honesty at home?',
        'What helps you stay calm?',
        'How do you show respect to nature?',
        'What makes you laugh the most?',
        'How do you celebrate your learning?',
        'What helps you do your best?',
        'What is the best way to stay healthy?',
        'How do you show teamwork in sports?',
        'What helps you understand stories?',
        'How do you show you are a good listener?',
        'What helps you be safe on the playground?',
        'How do you show respect at school?',
        'What makes you excited to learn?',
        'How do you encourage others?',
        'What helps you when you feel nervous?'
      ],
      '4': [
        'What helps you calm down when you feel upset?',
        'How can you show respect to your classmates?',
        'What makes a team work well together?',
        'What helps you do your best work?',
        'How can you show honesty at school?',
        'What helps you remember something new?',
        'How do you show responsibility in class?',
        'What makes you proud of yourself?',
        'What helps you learn to read?',
        'How can you show kindness every day?',
        'What helps you solve a problem?',
        'What makes learning fun?',
        'How can you show respect at home?',
        'What helps you stay safe outside?',
        'How do you show teamwork in sports?',
        'What helps you when you feel nervous?',
        'How can you care for nature?',
        'What makes you a good friend?',
        'What helps you relax after school?',
        'How can you show fairness on the playground?',
        'What makes you laugh the most?',
        'How do you get ready for school?',
        'What helps you learn more about the world?',
        'How can you show care for a new student?',
        'What makes you feel calm?',
        'How can you celebrate your hard work?',
        'What helps you stay healthy?',
        'How do you show respect to teachers?',
        'What helps you keep trying when it is hard?',
        'How do you show kindness on the playground?',
        'What makes you feel safe at school?',
        'What helps you learn in math?',
        'How do you care for classroom materials?',
        'What makes you excited to learn?',
        'How can you be a good leader?',
        'What helps you when you feel sad?',
        'How do you show respect for nature?',
        'What makes a school day great?',
        'How can you show honesty with your friends?',
        'What helps you be ready to learn?',
        'How do you show teamwork in class?',
        'What makes you feel included in a group?',
        'How can you show respect during a story?',
        'What helps you solve puzzles?',
        'How do you show kindness at home?',
        'What makes you happy at school?',
        'How do you care for yourself?',
        'What helps you stay focused during work?',
        'How can you show respect on a trip?',
        'What makes you feel proud in school?'
      ],
      wyr: [
        'Would you rather fly like a bird or swim like a fish?',
        'Would you rather live in a treehouse or in a castle?',
        'Would you rather read a storybook or write your own story?',
        'Would you rather play indoors on a rainy day or play outdoors in the sunshine?',
        'Would you rather be really tall or really small?',
        'Would you rather have a pet dog or a pet cat?',
        'Would you rather always be warm or always be cool?',
        'Would you rather be able to draw beautifully or sing beautifully?',
        'Would you rather ride a bicycle or ride a scooter?',
        'Would you rather have super speed or super strength?',
        'Would you rather visit the ocean or visit the mountains?',
        'Would you rather eat ice cream or eat cake?',
        'Would you rather play a game you always win or play a game that is always fun?',
        'Would you rather be invisible or be able to fly?',
        'Would you rather have a robot helper or a pet dinosaur?',
        'Would you rather watch a movie or play a board game?',
        'Would you rather read in the morning or read at night?',
        'Would you rather be really good at math or really good at reading?',
        'Would you rather travel to the past or travel to the future?',
        'Would you rather have lots of toys or lots of books?',
        'Would you rather live in outer space or live under the sea?',
        'Would you rather be the teacher for a day or be the student for a day?',
        'Would you rather eat pizza or eat spaghetti?',
        'Would you rather talk to animals or talk to plants?',
        'Would you rather have ten friends or one best friend?',
        'Would you rather play soccer or play basketball?',
        'Would you rather be able to run very fast or jump very high?',
        'Would you rather go camping or stay in a hotel?',
        'Would you rather play in the snow or play at the beach?',
        'Would you rather be able to speak another language or play a musical instrument?',
        'Would you rather spend a day drawing or spend a day building?',
        'Would you rather have a picnic in the park or a party indoors?',
        'Would you rather explore a forest or explore a city?',
        'Would you rather have pancakes for breakfast or cereal for breakfast?',
        'Would you rather read about animals or read about space?',
        'Would you rather be famous for writing a book or for inventing something?',
        'Would you rather swim in a pool or swim in a lake?',
        'Would you rather live where it is always summer or always winter?',
        'Would you rather eat only fruits or only vegetables for a week?',
        'Would you rather build a sandcastle or build a snowman?',
        'Would you rather climb a tall tree or dig a deep hole?',
        'Would you rather ride a horse or ride a train?',
        'Would you rather play a video game or play tag outside?',
        'Would you rather always have to whisper or always have to shout?',
        'Would you rather have a magic backpack or magic shoes?',
        'Would you rather live in a house made of candy or a house made of Lego bricks?',
        'Would you rather be able to breathe underwater or see in the dark?',
        'Would you rather always have to hop or always have to skip?',
        'Would you rather discover a new animal or discover a new planet?',
        'Would you rather spend a whole day reading or a whole day playing outside?'
      ]
    };
    
    // Define response choices for each question type
    const responseChoices = {
      open: ['üó£Ô∏è I\'ve got my answer and I\'m ready to explain it.'],
      '2': ['Option A', 'Option B'],
      '3': ['Take deep breaths', 'Talk to someone', 'Count slowly'],
      '4': ['Take deep breaths', 'Talk to a friend', 'Draw a picture', 'Go for a walk'],
      wyr: ['Option A', 'Option B']
    };
    
    // Define specific question-response pairs for better matching
    const questionResponsePairs = {
      'What is the best way to calm down?': ['Take deep breaths', 'Talk to someone', 'Count slowly'],
      'How can you solve a problem with a friend?': ['Talk about it', 'Ask an adult', 'Take a break'],
      'What helps you learn best?': ['Reading', 'Doing', 'Listening'],
      'What do you do when you make a mistake?': ['Try again', 'Ask for help', 'Learn from it'],
      'What is the most important part of being a good friend?': ['Sharing', 'Helping', 'Listening'],
      'How can you show respect?': ['Take turns', 'Listen quietly', 'Use kind words'],
      'What helps you focus in class?': ['Sitting quietly', 'Using tools', 'Working with a partner'],
      'What is the best way to celebrate success?': ['Cheer', 'Tell someone', 'Draw a picture'],
      'How do you show responsibility?': ['Clean up', 'Finish work', 'Follow rules'],
      'What makes a team strong?': ['Helping', 'Listening', 'Sharing'],
      'What helps you feel safe?': ['Following rules', 'Talking to an adult', 'Playing with friends'],
      'What is the best way to show honesty?': ['Tell the truth', 'Return lost things', 'Admit mistakes'],
      'What helps you get ready for school?': ['Pack your bag', 'Eat breakfast', 'Get sleep'],
      'How do you share with others?': ['Toys', 'Ideas', 'Time'],
      'What makes you feel proud?': ['Working hard', 'Helping others', 'Being kind'],
      'What is the best way to be fair?': ['Take turns', 'Listen to others', 'Share equally'],
      'What helps you remember?': ['Write it down', 'Repeat it', 'Act it out'],
      'What is the best way to welcome someone new?': ['Smile', 'Invite them', 'Talk to them'],
      'What helps you when you feel sad?': ['Talk to a friend', 'Take a break', 'Think happy thoughts'],
      'How do you show teamwork?': ['Listen', 'Share', 'Help'],
      'What helps you grow as a learner?': ['Practice', 'Feedback', 'Effort'],
      'What is the best way to be safe outside?': ['Look both ways', 'Stay with friends', 'Ask an adult'],
      'What helps you solve math problems?': ['Count', 'Draw', 'Use objects'],
      'How do you care for nature?': ['Pick up trash', 'Plant', 'Save water'],
      'What helps you be creative?': ['Drawing', 'Building', 'Imagining'],
      'How do you show kindness?': ['Smile', 'Help', 'Share'],
      'What helps you learn reading?': ['Pictures', 'Talking', 'Acting out'],
      'How do you show fairness?': ['Take turns', 'Share', 'Listen'],
      'What is the best way to learn more?': ['Ask questions', 'Read books', 'Talk to people'],
      'How do you solve puzzles?': ['Try again', 'Think harder', 'Ask for help'],
      'What makes learning fun?': ['Games', 'Stories', 'Projects'],
      'How do you show care for family?': ['Help', 'Listen', 'Share'],
      'What helps you when you feel stuck?': ['Ask', 'Rest', 'Try again'],
      'What helps you feel proud of your work?': ['Effort', 'Creativity', 'Kindness'],
      'How do you show honesty at home?': ['Tell the truth', 'Admit mistakes', 'Return things'],
      'What helps you stay calm?': ['Breathing', 'Counting', 'Quiet time'],
      'How do you show respect to nature?': ['Plant', 'Protect', 'Clean'],
      'What makes you laugh the most?': ['Jokes', 'Friends', 'Stories'],
      'How do you celebrate your learning?': ['Share with class', 'Draw', 'Tell your family'],
      'What helps you do your best?': ['Practice', 'Encouragement', 'Effort'],
      'What is the best way to stay healthy?': ['Eat well', 'Sleep', 'Exercise'],
      'How do you show teamwork in sports?': ['Pass', 'Encourage', 'Take turns'],
      'What helps you understand stories?': ['Pictures', 'Talking', 'Acting'],
      'How do you show you are a good listener?': ['Look at speaker', 'Be quiet', 'Ask questions'],
      'What helps you be safe on the playground?': ['Take turns', 'Follow rules', 'Watch out'],
      'How do you show respect at school?': ['Listen', 'Help', 'Share'],
      'What makes you excited to learn?': ['New books', 'Fun games', 'Interesting projects'],
      'How do you encourage others?': ['Say kind words', 'Cheer', 'Offer help'],
      'What helps you when you feel nervous?': ['Talk', 'Breathe', 'Think of good things'],
      
      // 4-choice question pairs
      'What helps you calm down when you feel upset?': ['Take deep breaths', 'Talk to a friend', 'Draw a picture', 'Go for a walk'],
      'How can you show respect to your classmates?': ['Listen carefully', 'Share materials', 'Use kind words', 'Take turns'],
      'What makes a team work well together?': ['Helping one another', 'Listening to ideas', 'Sharing fairly', 'Encouraging each other'],
      'What helps you do your best work?': ['Trying hard', 'Asking for help', 'Taking a short break', 'Staying focused'],
      'How can you show honesty at school?': ['Tell the truth', 'Admit your mistakes', 'Return things that are not yours', 'Keep your promises'],
      'What helps you remember something new?': ['Write it down', 'Say it out loud', 'Act it out', 'Draw a picture'],
      'How do you show responsibility in class?': ['Finish your work', 'Put materials away', 'Follow the rules', 'Be on time'],
      'What makes you proud of yourself?': ['Working hard', 'Helping someone', 'Trying again', 'Being kind'],
      'What helps you learn to read?': ['Looking at pictures', 'Sounding out words', 'Asking questions', 'Listening to the teacher'],
      'How can you show kindness every day?': ['Help a friend', 'Say kind words', 'Share with others', 'Smile at someone'],
      'What helps you solve a problem?': ['Talk about it', 'Try a new way', 'Ask for help', 'Work with a partner'],
      'What makes learning fun?': ['Playing games', 'Reading stories', 'Doing projects', 'Working with friends'],
      'How can you show respect at home?': ['Help with chores', 'Listen to family', 'Share fairly', 'Use polite words'],
      'What helps you stay safe outside?': ['Look both ways', 'Stay with a buddy', 'Ask an adult', 'Follow rules'],
      'How do you show teamwork in sports?': ['Pass the ball', 'Cheer for others', 'Take turns', 'Play fairly'],
      'How can you care for nature?': ['Recycle', 'Plant something', 'Pick up litter', 'Save water'],
      'What makes you a good friend?': ['Listening', 'Sharing', 'Helping', 'Playing kindly'],
      'What helps you relax after school?': ['Read a book', 'Listen to music', 'Go outside', 'Draw a picture'],
      'How can you show fairness on the playground?': ['Take turns', 'Invite others', 'Follow rules', 'Share equipment'],
      'What makes you laugh the most?': ['Jokes', 'Funny stories', 'Playing games', 'Being with friends'],
      'How do you get ready for school?': ['Pack your bag', 'Eat breakfast', 'Get dressed', 'Brush your teeth'],
      'What helps you learn more about the world?': ['Read books', 'Ask questions', 'Explore outside', 'Talk to people'],
      'How can you show care for a new student?': ['Smile at them', 'Sit with them', 'Invite them to play', 'Ask them questions'],
      'What makes you feel calm?': ['Quiet time', 'Drawing', 'Breathing', 'Gentle music'],
      'How can you celebrate your hard work?': ['Tell your family', 'Show the class', 'Draw a picture', 'Clap for yourself'],
      'What helps you stay healthy?': ['Eat healthy food', 'Get enough sleep', 'Exercise', 'Drink water'],
      'How do you show respect to teachers?': ['Listen', 'Follow instructions', 'Say thank you', 'Ask questions politely'],
      'What helps you keep trying when it is hard?': ['Encouragement', 'Taking a break', 'Thinking of new ideas', 'Practicing more'],
      'How do you show kindness on the playground?': ['Share equipment', 'Play fairly', 'Invite others', 'Take turns'],
      'What makes you feel safe at school?': ['Following rules', 'Staying with friends', 'Talking to an adult', 'Listening to directions'],
      'What helps you learn in math?': ['Using objects', 'Drawing pictures', 'Counting carefully', 'Practicing problems'],
      'How do you care for classroom materials?': ['Put them away', 'Share them', 'Use them carefully', 'Return them on time'],
      'What makes you excited to learn?': ['New books', 'Fun projects', 'Games', 'Working with friends'],
      'How can you be a good leader?': ['Listen to ideas', 'Help others', 'Make fair choices', 'Encourage the group'],
      'What helps you when you feel sad?': ['Talk to someone', 'Take a break', 'Think of happy memories', 'Play outside'],
      'How do you show respect for nature?': ['Do not litter', 'Protect animals', 'Plant trees', 'Recycle'],
      'What makes a school day great?': ['Learning something new', 'Playing with friends', 'Reading a story', 'Doing art'],
      'How can you show honesty with your friends?': ['Tell the truth', 'Admit a mistake', 'Keep a promise', 'Share your feelings'],
      'What helps you be ready to learn?': ['Bring materials', 'Listen carefully', 'Sit quietly', 'Focus on the task'],
      'How do you show teamwork in class?': ['Work together', 'Share ideas', 'Take turns', 'Listen to others'],
      'What makes you feel included in a group?': ['Being invited', 'Having a role', 'Being listened to', 'Playing together'],
      'How can you show respect during a story?': ['Sit quietly', 'Listen closely', 'Look at the reader', 'Ask questions after'],
      'What helps you solve puzzles?': ['Try again', 'Think carefully', 'Work with someone', 'Use clues'],
      'How do you show kindness at home?': ['Help with chores', 'Say kind words', 'Share with family', 'Listen carefully'],
      'What makes you happy at school?': ['Friends', 'Learning', 'Playing', 'Creating'],
      'How do you care for yourself?': ['Eat well', 'Get sleep', 'Stay active', 'Be kind to yourself'],
      'What helps you stay focused during work?': ['Sit quietly', 'Use tools', 'Take a break', 'Set a goal'],
      'How can you show respect on a trip?': ['Follow rules', 'Stay with the group', 'Listen carefully', 'Use polite words'],
      'What makes you feel proud in school?': ['Trying your best', 'Helping others', 'Learning something new', 'Being kind']
    };
    
    // Determine the question type based on count
    let questionType;
    if (count === 1) questionType = 'open';
    else if (count === 2) questionType = '2';
    else if (count === 3) questionType = '3';
    else if (count === 4) questionType = '4';
    else if (count === 'wyr') questionType = 'wyr';
    else questionType = '4'; // Default to 4-choice questions
    
    // Get available questions for this type
    let availableQuestions = questionBank[questionType] || questionBank['4'];
    
    // Filter out already used questions
    let unusedQuestions = availableQuestions.filter(q => !usedQuestions[q]);
    
    // If all questions have been used, reset the tracking for this type
    if (unusedQuestions.length === 0) {
      console.log(`All ${questionType} questions have been used, resetting tracking for this type`);
      // Remove tracking for this question type only
      Object.keys(usedQuestions).forEach(q => {
        if (questionBank[questionType].includes(q)) {
          delete usedQuestions[q];
        }
      });
      unusedQuestions = questionBank[questionType];
    }
    
    // Select a random unused question
    const selectedQuestion = unusedQuestions[Math.floor(Math.random() * unusedQuestions.length)];
    
    // Mark this question as used
    usedQuestions[selectedQuestion] = true;
    localStorage.setItem('mxq_used_questions', JSON.stringify(usedQuestions));
    
    // Get the appropriate response choices - check for specific question-response pairs first
    let choices;
    
    if (questionResponsePairs[selectedQuestion]) {
      // Use the specific responses for this exact question
      choices = questionResponsePairs[selectedQuestion];
      console.log(`Using specific responses for: "${selectedQuestion}"`);
    } else {
      // Fall back to generic responses for this question type
      choices = responseChoices[questionType] || responseChoices['4'];
      console.log(`Using generic responses for: "${selectedQuestion}"`);
    }
    
    // Ensure we have the right number of choices for the requested count
    if (questionType === '3' && choices.length > 3) {
      choices = choices.slice(0, 3);
    } else if (questionType === '4' && choices.length > 4) {
      choices = choices.slice(0, 4);
    } else if (questionType === '2' && choices.length > 2) {
      choices = choices.slice(0, 2);
    }
    
    // Apply concise mode if requested
    if (concise) {
      const words = selectedQuestion.split(' ');
      if (words.length > 12) {
        selectedQuestion = words.slice(0, 12).join(' ') + '...';
      }
      choices = choices.map(c => {
        const words = c.split(' ');
        return words.length > 5 ? words.slice(0, 5).join(' ') + '...' : c;
      });
    }
    
    // Add emojis to choices
    choices = addEmojisUnique(choices);
    
    console.log(`Selected offline question: "${selectedQuestion}" (Type: ${questionType}, Used: ${Object.keys(usedQuestions).length}/${availableQuestions.length})`);
    
    localStorage.setItem('mxq_ai_lastgen', JSON.stringify({used:'offline',questionSource:'offline',time:Date.now()}));
    return {question: selectedQuestion, choices, fromBank: true};
  }
  async function getQ(count,kw,grade,subject,ls,blooms,concise){
    try{
      const key = getKey();
      if(!key) {
        throw new Error('No key');
      }
      return await geminiQ(count,kw,grade,subject,ls,blooms,concise);
    }catch(e){
      console.log('AI generation failed, falling back to offline:', e.message);
      return offlineQ(count,subject,ls,concise);
    }
  }

  // ---------- settings ----------
  function toggleAnswerFields(mode){
    const grid=document.querySelector('.answers-grid'); grid.style.display=(mode==='open')?'none':'grid';
    const show=n=>$('#a'+n).parentElement.style.display='flex', hide=n=>$('#a'+n).parentElement.style.display='none';
    show(1);show(2);show(3);show(4);
    if(mode==='2'){hide(3);hide(4)} 
    if(mode==='3'){show(3);hide(4)} 
    if(mode==='4'){show(3);show(4)}
    if(mode==='wyr'){
      hide(3);hide(4);
      // Set default "Would you rather" options
      $('#a1').value = 'Option A';
      $('#a2').value = 'Option B';
    }
  }
  function getSelectedResponseMode() {
    const activeBtn = document.querySelector('.response-btn.active');
    return activeBtn ? activeBtn.dataset.value : '4';
  }
  
  function setSelectedResponseMode(mode) {
    document.querySelectorAll('.response-btn').forEach(btn => {
      btn.classList.toggle('active', btn.dataset.value === mode);
    });
  }
  
  function openSettings(){
    const s=load('mxq_choices'); $('#qInput').value=s?.q||$('#question').textContent||'';
    const mode=s?.mode||'4'; setSelectedResponseMode(mode);
    const cur=s?.choices || Array.from(document.querySelectorAll('.zone h3')).map(h=>h.textContent);
    ['a1','a2','a3','a4'].forEach((id,i)=> $('#'+id).value=(cur[i]||'').replace(/^(\p{Emoji_Presentation}|\p{Emoji})\s*/u,'')); // allow editing text without emoji
          $('#gradeInput').value=load('mxq_grade','-'); $('#subjectInput').value=load('mxq_subject','-'); $('#lsInput').value=load('mxq_ls','-'); $('#keywordInput').value=load('mxq_keywords',''); $('#bloomsInput').value=load('mxq_blooms','-');
    $('#conciseToggle').checked = !!load('mxq_concise', false);
    $('#selInput').value=load('mxq_sel','');
    toggleAnswerFields(mode); $('#settingsModal').classList.add('show'); aiStatus();
    
    // Populate SEL dropdown based on current grade
    populateSELDropDown();
  }
  // Response button handlers
  document.querySelectorAll('.response-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
      // Remove active class from all buttons
      document.querySelectorAll('.response-btn').forEach(b => b.classList.remove('active'));
      // Add active class to clicked button
      e.target.classList.add('active');
      // Toggle answer fields based on selected value
      toggleAnswerFields(e.target.dataset.value);
    });
  });

  // Grade change handler to update SEL dropdown
  document.getElementById('gradeInput')?.addEventListener('change', populateSELDropDown);
  
  // Save SEL value when it changes
  document.getElementById('selInput')?.addEventListener('change', (e) => {
    save('mxq_sel', e.target.value);
  });
  document.addEventListener('keydown',e=>{ 
    console.log('Key pressed:', e.key, 'Code:', e.code);
    // Check if user is typing in an input field
    const isTyping = e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT');
    
    if(e.key==='Enter'&&$('#settingsModal').classList.contains('show')){ 
      e.preventDefault(); 
      $('#genBtn').click(); 
    }
    
    // Enter key on main page generates new question
    if(e.key==='Enter' && !$('#settingsModal').classList.contains('show') && !$('#aiModal').classList.contains('show')){
      e.preventDefault();
      generateWithCurrentSettings();
    }
    
    // Hotkeys that work without modifiers (only when not typing)
    if(!isTyping){
      // R key triggers reset actions
      if(e.key.toLowerCase()==='r' && !e.ctrlKey && !e.altKey && !e.metaKey){
        // If settings modal is open, reset filters
        if($('#settingsModal').classList.contains('show')){
          $('#resetFiltersBtn').click();
        }
        // Always trigger main page reset (students to parking + timer reset)
        $('#quickReset').click();
      }
      // G key triggers AI generation
      if(e.key.toLowerCase()==='g' && !e.ctrlKey && !e.altKey && !e.metaKey){
        // If settings modal is open, generate with current settings
        if($('#settingsModal').classList.contains('show')){
          $('#genBtn').click();
        } else {
          // On main page, generate with current saved settings
          generateWithCurrentSettings();
        }
      }
      // S key opens settings
      if(e.key.toLowerCase()==='s' && !e.ctrlKey && !e.altKey && !e.metaKey){
        if(!$('#settingsModal').classList.contains('show')){
          openSettings();
        }
      }
      // A key opens settings + AI settings
      if(e.key.toLowerCase()==='a' && !e.ctrlKey && !e.altKey && !e.metaKey){
        if(!$('#settingsModal').classList.contains('show')){
          openAISettings();
        }
      }
      // Response number hotkeys
      if(['1','2','3','4'].includes(e.key) && !e.ctrlKey && !e.altKey && !e.metaKey){
        const mode = e.key === '1' ? 'open' : e.key;
        setResponseModeAndGenerate(mode);
      }
      // W key for Would You Rather
      if(e.key.toLowerCase()==='w' && !e.ctrlKey && !e.altKey && !e.metaKey){
        setResponseModeAndGenerate('wyr');
      }
      // T key for timer (main page only)
      if(e.key.toLowerCase()==='t' && !e.ctrlKey && !e.altKey && !e.metaKey){
        if(!$('#settingsModal').classList.contains('show')){
          toggleRun();
        }
      }
      // P key for partner function (main page only)
      if(e.key.toLowerCase()==='p' && !e.ctrlKey && !e.altKey && !e.metaKey){
        if(!$('#settingsModal').classList.contains('show')){
          createPartners();
        }
      }
      
      // Arrow keys for group size and timer (main page only)
      if(!$('#settingsModal').classList.contains('show') && !$('#aiModal').classList.contains('show')){
        // Up/Down arrows for group size
        if(e.key === 'ArrowUp' && !e.ctrlKey && !e.altKey && !e.metaKey){
          e.preventDefault();
          changeGroupSize(1);
        }
        if(e.key === 'ArrowDown' && !e.ctrlKey && !e.altKey && !e.metaKey){
          e.preventDefault();
          changeGroupSize(-1);
        }
        
        // Left/Right arrows for timer
        if(e.key === 'ArrowLeft' && !e.ctrlKey && !e.altKey && !e.metaKey){
          e.preventDefault();
          add(-30);
        }
        if(e.key === 'ArrowRight' && !e.ctrlKey && !e.altKey && !e.metaKey){
          e.preventDefault();
          add(30);
        }
      }
    }
    
    // Hotkeys that work even when typing (for specific keys)
    // ? key and spacebar for random student selection or closing winner modal (main page only)
    if((e.key==='?' || e.key===' ') && !e.ctrlKey && !e.altKey && !e.metaKey && !isTyping){
      e.preventDefault(); // Prevent default browser behavior
      
      // If winner modal is open, close it
      if($('#winnerModal').classList.contains('show')){
        $('#winnerModal').classList.remove('show');
      }
      // Otherwise, if on main page, start randomizer
      else if(!$('#settingsModal').classList.contains('show') && !$('#aiModal').classList.contains('show')){
        console.log(e.key + ' key pressed - starting randomizer');
        randomPick();
      }
    }
    // Alternative: / key for random student selection (main page only)
    if(e.key==='/' && !e.ctrlKey && !e.altKey && !e.metaKey && !isTyping){
      console.log('/ key pressed - attempting random pick');
      e.preventDefault(); // Prevent default browser behavior
      if(!$('#settingsModal').classList.contains('show') && !$('#aiModal').classList.contains('show')){
        console.log('Settings modal not open, calling randomPick()');
        randomPick();
      } else {
        console.log('Settings modal is open, not calling randomPick()');
      }
    }
    // Escape key to close modals
    if(e.key==='Escape' && !e.ctrlKey && !e.altKey && !e.metaKey){
      if($('#settingsModal').classList.contains('show')){
        $('#settingsModal').classList.remove('show');
      }
      if($('#aiModal').classList.contains('show')){
        $('#aiModal').classList.remove('show');
      }
      if($('#winnerModal').classList.contains('show')){
        $('#winnerModal').classList.remove('show');
      }
    }
    
    // Hotkeys that work with Cmd/Ctrl modifier (even when typing)
    if(e.ctrlKey || e.metaKey){
      // Cmd/Ctrl + R: Reset
      if(e.key.toLowerCase()==='r'){
        e.preventDefault();
        if($('#settingsModal').classList.contains('show')){
          $('#resetFiltersBtn').click();
        }
        $('#quickReset').click();
      }
      // Cmd/Ctrl + G: Generate
      if(e.key.toLowerCase()==='g'){
        e.preventDefault();
        if($('#settingsModal').classList.contains('show')){
          $('#genBtn').click();
        } else {
          generateWithCurrentSettings();
        }
      }
      // Cmd/Ctrl + S: Settings
      if(e.key.toLowerCase()==='s'){
        e.preventDefault();
        if(!$('#settingsModal').classList.contains('show')){
          openSettings();
        }
      }
      // Cmd/Ctrl + A: AI Settings
      if(e.key.toLowerCase()==='a'){
        e.preventDefault();
        if(!$('#settingsModal').classList.contains('show')){
          openAISettings();
        }
      }
      // Cmd/Ctrl + Response numbers
      if(['1','2','3','4'].includes(e.key)){
        e.preventDefault();
        const mode = e.key === '1' ? 'open' : e.key;
        setResponseModeAndGenerate(mode);
      }
      // Cmd/Ctrl + W: Would You Rather
      if(e.key.toLowerCase()==='w'){
        e.preventDefault();
        setResponseModeAndGenerate('wyr');
      }
    }
  });
  $('#openSettings').onclick=openSettings;
  $('#closeSettings').onclick=()=>$('#settingsModal').classList.remove('show');
  $('#applySettings').onclick=()=>{
    console.log('Apply Settings button clicked');
    try {
      const mode=getSelectedResponseMode();
      console.log('Selected mode:', mode);
      const q=$('#qInput').value.trim()||'Which choice fits you best right now? Explain why.';
      console.log('Question value:', q);
      // Check if this is a manually typed question (different from the current displayed question)
      const currentQuestion = $('#question').textContent.trim();
      const isManual = q !== currentQuestion && q.length > 0;
      console.log('Is manual question:', isManual, 'Current:', currentQuestion, 'New:', q);
      setQuestionSafe(q, false, false, isManual);
      const lines=(mode==='open')?[]:[$('#a1').value,$('#a2').value,$('#a3').value,$('#a4').value].map(s=>s.trim()).filter(Boolean);
      console.log('Answer lines:', lines);
      applyChoices(mode,lines);
      const saved=load('mxq_choices')||{}; save('mxq_choices',{...saved,q:$('#question').textContent});
      save('mxq_grade',$('#gradeInput').value); save('mxq_subject',$('#subjectInput').value); save('mxq_ls',$('#lsInput').value);
      save('mxq_keywords',$('#keywordInput').value); save('mxq_blooms',$('#bloomsInput').value);
      save('mxq_concise',$('#conciseToggle').checked);
      console.log('Settings saved, closing modal');
      $('#settingsModal').classList.remove('show');
      console.log('Modal closed');
    } catch (error) {
      console.error('Error in applySettings:', error);
      alert('Error saving settings: ' + error.message);
    }
  };

  function updateAIWarning(message, isError = false) {
    const status = $('#aiStatus');
    if (isError) {
      status.style.display = 'inline';
      if (message.includes('Rate Limit')) {
        status.textContent = '‚ö†Ô∏è';
        status.style.color = '#f59e0b'; // Orange for rate limit
      } else {
        status.textContent = '‚ùå';
        status.style.color = '#ef4444'; // Red for other errors
      }
    } else {
      status.style.display = 'none';
    }
  }
  
  function aiStatus(){
    const s=load('mxq_ai_status');
    const main=$('#aiStatusMain'), det=$('#aiStatusDetail'), det2=$('#aiStatusDetail2');
    const status=$('#aiStatus');
    let mainMsg='AI: not checked', detailMsg='Status: not checked';
    let showStatus=false;
    let statusSymbol='‚ùå';
    let statusColor='#ef4444';
    
    if(s){
      const t=new Date(s.time).toLocaleTimeString(); 
      
      // Check if there's a rate limit error
      const lastError = localStorage.getItem('mxq_last_ai_error');
      const activeKey = getActiveKeyName();
      
      // Only show rate limit error if the current active key actually failed
      const lastFailedKey = localStorage.getItem('mxq_last_failed_key');
      const isCurrentKeyFailed = lastFailedKey === activeKey;
      
      if(lastError && lastError.includes('quota exceeded') && isCurrentKeyFailed) {
        mainMsg = `Rate limit exceeded ‚ö†Ô∏è (${activeKey}) [${t}]`;
        detailMsg = `Status: Rate limit exceeded ‚ö†Ô∏è (${activeKey}) [${t}]`;
        showStatus = true;
        statusSymbol = '‚ö†Ô∏è';
        statusColor = '#f59e0b'; // Orange for warning
      } else if(s.ok) {
        mainMsg = `Connected ‚úÖ (${activeKey}) [${t}]`;
        detailMsg = mainMsg.replace('AI: ','Status: ');
        showStatus = true;
        statusSymbol = '‚úÖ';
        statusColor = '#22c55e'; // Green for connected
      } else {
        mainMsg = `Not connected ‚ùå (${activeKey}) [${t}]`;
        detailMsg = mainMsg.replace('AI: ','Status: ');
        showStatus = true;
        statusSymbol = '‚ùå';
        statusColor = '#ef4444'; // Red for not connected
      }
    } else {
      showStatus = true;
      statusSymbol = '‚ùå';
      statusColor = '#ef4444'; // Red for not checked
      mainMsg = 'AI: not checked';
      detailMsg = 'Status: not checked';
    }
    
    main.textContent=mainMsg; 
    if(det) det.textContent=detailMsg; 
    if(det2) det2.textContent=detailMsg;
    
    // Show/hide status indicator on main page
    if(showStatus) {
      status.style.display = 'inline';
      status.textContent = statusSymbol;
      status.style.color = statusColor;
    } else {
      status.style.display = 'none';
    }
    
    // Update progress bar when status changes
    updateTokenProgress();
  }
  $('#aiBtn').onclick=async()=>{ 
    const savedKey = load('mxq_ai_key');
    $('#aiKey').value = savedKey || 'AIzaSyDpx9ITK7RRlxYgbVaF_gkDJAAdmkjBzoQ'; 
    $('#aiModel').value=load('mxq_ai_model')||'gemini-2.0-flash'; 
    $('#aiModal').classList.add('show'); 
    
    // Initialize Quick Switch buttons first
    updateQuickSwitchButtons(); // Initialize Quick Switch buttons
    
    // Debug: Check current active key
    const currentActiveKey = getActiveKeyName();
    console.log('Modal opened - current active key:', currentActiveKey);
    
    // Force initial button state update
    updateKeyButtons();
    
    // Force a fresh connection test to get current status
    const testResult = await (async()=>{
      console.log('Modal opened - testing current key connection...');
      const key = getKey();
      console.log('Testing key:', key.substring(0, 10) + '...' + key.substring(key.length - 10));
      const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${key}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: 'test' }] }]
        })
      });
      
      console.log('Test result status:', res.status);
      
      if(!res.ok) {
        const errorText = await res.text();
        if(res.status === 429) {
          localStorage.setItem('mxq_last_ai_error', 'Daily quota exceeded (200 requests). Resets at midnight Pacific Time.');
          localStorage.setItem('mxq_last_failed_key', getActiveKeyName());
        } else {
          localStorage.setItem('mxq_last_ai_error', `HTTP ${res.status} error`);
          localStorage.setItem('mxq_last_failed_key', getActiveKeyName());
        }
        return false;
      }
      
      // Clear any previous errors for this key
      localStorage.removeItem('mxq_last_ai_error');
      localStorage.removeItem('mxq_last_failed_key');
      return true;
    })();
    
    // Update status based on test result
    const statusObj = {
      ok: testResult,
      time: Date.now()
    };
    localStorage.setItem('mxq_ai_status', JSON.stringify(statusObj));
    
    // Debug: Check final active key
    const finalActiveKey = getActiveKeyName();
    console.log('Modal opened - final active key:', finalActiveKey, 'test result:', testResult);
    
    // Now update UI with correct status
    aiStatus();
    
    // Force a small delay to ensure DOM is ready, then update buttons
    setTimeout(() => {
      updateKeyButtons();
      updateTokenProgress();
    }, 50);
  };
  $('#aiSave').onclick=()=>{ save('mxq_ai_key',$('#aiKey').value.trim()); save('mxq_ai_model',$('#aiModel').value.trim()); $('#aiModal').classList.remove('show'); toast('AI settings saved'); aiStatus(); };
  $('#aiClose').onclick=()=>$('#aiModal').classList.remove('show');
  
  // Reset filters button
  $('#resetFiltersBtn').onclick=()=>{
    $('#gradeInput').value='-';
    $('#subjectInput').value='-';
    $('#lsInput').value='-';
    $('#keywordInput').value='';
    $('#bloomsInput').value='-';
    $('#conciseToggle').checked=false;
    $('#selInput').value='-';
    setSelectedResponseMode('4');
    toggleAnswerFields('4');
    populateSELDropDown(); // Update SEL dropdown for new grade
    
    // Also clear any saved keywords (both global and run-scoped)
    save('mxq_keywords', '');
    save('mxq_keywords_active', '');
    $('#keywordInput').value = '';
    
    // Reset question tracking to start fresh
    localStorage.removeItem('mxq_used_questions');
    console.log('Question tracking reset - all questions will be available again');
    
    toast('Filters, keywords & question tracking cleared');
  };
  
  $('#aiTest').onclick=async()=>{ 
    console.log('=== AI CONNECTION TEST START ===');
    console.log('Current timestamp:', Date.now());
    console.log('Forcing fresh test...');
    console.log('Using FIXED version of the file');
    
    // Clear only model settings, keep error state for progress bar
    localStorage.removeItem('mxq_ai_model');
    console.log('Cleared model settings, keeping error state');
    
    const ok = await (async()=>{
      try{
        // Check if we can even get the key
        const key = getKey();
        console.log('API Key retrieved, length:', key.length);
        console.log('API Key starts with:', key.substring(0, 10) + '...');
        console.log('API Key ends with:', key.substring(key.length - 10));
        
        if(!key || key.length < 10) {
          console.log('ERROR: Invalid API key');
          return false;
        }
        
        // Try the simplest possible test with the working model
        const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${encodeURIComponent(key)}`;
        console.log('Making request to:', url.substring(0, 100) + '...');
        
        const res = await fetch(url, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            contents:[{
              role:'user',
              parts:[{text:'Say "hello"'}]
            }]
          })
        });
        
        console.log('Response status:', res.status);
        console.log('Response ok:', res.ok);
        console.log('Response headers:', Object.fromEntries(res.headers.entries()));
        
        if(!res.ok) {
          const errorText = await res.text();
          console.log('ERROR: Response not ok:', res.status, errorText);
          
                          // Check if it's a rate limit error
        if(res.status === 429) {
          localStorage.setItem('mxq_last_ai_error', 'Daily quota exceeded (200 requests). Resets at midnight Pacific Time.');
          localStorage.setItem('mxq_last_failed_key', getActiveKeyName());
          console.log('Rate limit detected for key:', getActiveKeyName());
        } else {
          localStorage.setItem('mxq_last_ai_error', `HTTP ${res.status} error`);
          localStorage.setItem('mxq_last_failed_key', getActiveKeyName());
        }
        
        // Update progress bar to show rate limit
        updateTokenProgress();
        
        // Try auto-switching to backup key
        console.log('Attempting auto-switch to backup key...');
        const switchResult = await autoSwitchToBackup();
        if(switchResult) {
          console.log('Auto-switch successful, retesting connection...');
          return await (async()=>{
            const key = getKey();
            const res = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${key}`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                contents: [{ parts: [{ text: 'test' }] }]
              })
            });
            return res.ok;
          })();
        }
        
        return false;
        }
        
        const data = await res.json();
        console.log('SUCCESS: Got response:', data);
        
        // Increment token usage for successful request
        incrementTokenUsage(getActiveKeyName());
        updateTokenProgress();
        
        return true;
        
      }catch(e){
        console.log('ERROR: Exception caught:', e.message);
        console.log('ERROR: Full error:', e);
        console.log('ERROR: Stack trace:', e.stack);
        return false;
      }
    })(); 
    console.log('=== AI CONNECTION TEST END ===');
    console.log('Final result:', ok);
    save('mxq_ai_status',{ok,provider:'gemini',time:Date.now()}); 
    aiStatus(); 
    toast(ok?'AI connected':'AI not connected'); 
  };
  
  $('#keyMain').onclick=()=>{
    switchToKey('main');
  };
  
  $('#keyBU1').onclick=()=>{
    switchToKey('BU1');
  };
  
  $('#keyBU2').onclick=()=>{
    switchToKey('BU2');
  };
  
  // Quick Switch button event listeners
  $('#model2Flash').onclick=()=>{
    $('#aiModel').value = 'gemini-2.0-flash';
    updateQuickSwitchButtons();
    toast('Switched to Gemini 2.0 Flash');
  };
  
  $('#model1Flash').onclick=()=>{
    $('#aiModel').value = 'gemini-1.5-flash';
    updateQuickSwitchButtons();
    toast('Switched to Gemini 1.5 Flash');
  };
  
  $('#model1Pro').onclick=()=>{
    $('#aiModel').value = 'gemini-1.5-pro';
    updateQuickSwitchButtons();
    toast('Switched to Gemini 1.5 Pro');
  };

  async function setResponseModeAndGenerate(mode){
    console.log('=== SET RESPONSE MODE AND GENERATE ===', mode);
    
    // Update the saved choices with new mode
    const saved=load('mxq_choices')||{};
    saved.mode = mode;
    save('mxq_choices', saved);
    
    // If in settings modal, update the UI
    if($('#settingsModal').classList.contains('show')){
      setSelectedResponseMode(mode);
      toggleAnswerFields(mode);
    }
    
    // Generate new question with current settings and new mode
    const count = mode==='open' ? 1 : mode==='wyr' ? 2 : parseInt(mode,10);
    let kw = load('mxq_keywords','');  // legacy default
    const grade=load('mxq_grade',''),
          subject=load('mxq_subject',''),
          ls=load('mxq_ls',''),
          blooms=load('mxq_blooms','');
    const concise=!!load('mxq_concise',false);
    
    // Prefer run-scoped keywords if present, otherwise empty string (don't drag stale ones)
    const active = load('mxq_keywords_active','');
    kw = (typeof active === 'string') ? active.trim() : '';
    save('mxq_keywords_active', kw);
    
    console.log('Generation params:', {mode, count, kw, grade, subject, ls, blooms, concise});
    
    try{
      console.log('Attempting Gemini AI generation...');
      const out=await geminiQ({count: count===1?4:count, kw, grade, subject, ls, blooms, concise});
      console.log('Gemini AI generation result:', out);
      
      // Validate and repair the generated question
      let candidate = {question: out.question, choices: out.choices};
      let check = validateGeneratedQuestion(candidate);
      if(!check || check.valid === false){
        console.log('Validation failed, attempting repair:', check?.issues);
        const fixed = repairGeneratedQuestion(candidate);
        if(fixed){
          candidate = fixed;
          check = validateGeneratedQuestion(candidate);
        }
      }
      if(!check || check.valid === false){
        console.warn('Validation failed after repair:', check?.issues);
        // graceful fallback to offline bank
        const off = offlineQ(count===1?4:count,subject,ls,concise);
        candidate = {question: off.question, choices: off.choices};
      }
      
      console.log('Setting question:', candidate.question);
      await setQuestionSafe(candidate.question, false, false, false);
      
      console.log('Applying choices:', candidate.choices);
      applyChoices(count===1?'open':String(count), candidate.choices);
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast(`AI generated (${mode} responses)`);
      console.log('=== GENERATION COMPLETE ===');
    }catch(e){
      console.log('Gemini AI generation failed, using offline:', e);
      const out=offlineQ(count===1?4:count,subject,ls,concise);
      await setQuestionSafe(out.question, false, out.fromBank, false);
      applyChoices(count===1?'open':String(count), out.choices);
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast(`AI (offline) (${mode} responses)`);
    }
  }

  async function generateWithCurrentSettings(){
    console.log('=== GENERATE WITH CURRENT SETTINGS ===');
    const saved=load('mxq_choices')||{};
    const modeSel=saved.mode||'4';
    const count = modeSel==='open' ? 1 : modeSel==='wyr' ? 2 : parseInt(modeSel,10);
    let kw = load('mxq_keywords','');  // legacy default
    const grade=load('mxq_grade',''),
          subject=load('mxq_subject',''),
          ls=load('mxq_ls',''),
          blooms=load('mxq_blooms','');
    const concise=!!load('mxq_concise',false);
    
    // Prefer run-scoped keywords if present, otherwise empty string (don't drag stale ones)
    const active = load('mxq_keywords_active','');
    kw = (typeof active === 'string') ? active.trim() : '';
    save('mxq_keywords_active', kw);
    
    console.log('Generation params:', {modeSel, count, kw, grade, subject, ls, blooms, concise});
    
    try{
      console.log('Attempting AI generation...');
      const out=await geminiQ({count: count===1?4:count, kw, grade, subject, ls, blooms, concise});
      console.log('AI generation result:', out);
      
      // Validate and repair the generated question
      let candidate = {question: out.question, choices: out.choices};
      let check = validateGeneratedQuestion(candidate);
      if(!check || check.valid === false){
        console.log('Validation failed, attempting repair:', check?.issues);
        const fixed = repairGeneratedQuestion(candidate);
        if(fixed){
          candidate = fixed;
          check = validateGeneratedQuestion(candidate);
        }
      }
      if(!check || check.valid === false){
        console.warn('Validation failed after repair:', check?.issues);
        // graceful fallback to offline bank
        const off = offlineQ(count===1?4:count,subject,ls,concise);
        candidate = {question: off.question, choices: off.choices};
      }
      
      console.log('Setting question:', candidate.question);
      await setQuestionSafe(candidate.question, false, false, false);
      
      console.log('Applying choices:', candidate.choices);
      applyChoices(count===1?'open':String(count), candidate.choices);
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast('AI generated');
      console.log('=== GENERATION COMPLETE ===');
    }catch(e){
      console.log('AI generation failed, using offline:', e);
      const out=offlineQ(count===1?4:count,subject,ls,concise);
      await setQuestionSafe(out.question, false, out.fromBank, false);
      applyChoices(count===1?'open':String(count), out.choices);
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast('AI (offline)');
    }
  }

  $('#genBtn').onclick=async()=>{
    console.log('=== GENERATE BUTTON CLICKED ===');
    const modeSel=getSelectedResponseMode();
    const count = modeSel==='open' ? 1 : modeSel==='wyr' ? 2 : parseInt(modeSel,10);
    const kw=$('#keywordInput').value.trim(),
          grade=$('#gradeInput').value,
          subject=$('#subjectInput').value,
          ls=$('#lsInput').value,
          blooms=$('#bloomsInput').value;
    const concise=!!$('#conciseToggle').checked; 
    save('mxq_concise', concise);
    
    // run-scoped keywords (only for this generation)
    save('mxq_keywords_active', kw);
    
    console.log('Generation params:', {modeSel, count, kw, grade, subject, ls, blooms, concise});
    
    try{
      console.log('Attempting AI generation...');
      const out=await geminiQ({count: count===1?4:count, kw, grade, subject, ls, blooms, concise});
      console.log('AI generation result:', out);
      
      // Validate and repair the generated question
      let candidate = {question: out.question, choices: out.choices};
      let check = validateGeneratedQuestion(candidate);
      if(!check || check.valid === false){
        console.log('Validation failed, attempting repair:', check?.issues);
        const fixed = repairGeneratedQuestion(candidate);
        if(fixed){
          candidate = fixed;
          check = validateGeneratedQuestion(candidate);
        }
      }
      if(!check || check.valid === false){
        console.warn('Validation failed after repair:', check?.issues);
        // graceful fallback to offline bank
        const off = offlineQ(count===1?4:count,subject,ls,concise);
        candidate = {question: off.question, choices: off.choices};
      }
      
      console.log('Setting question:', candidate.question);
      await setQuestionSafe(candidate.question, false, false, false);                  // paint first and wait
      
      console.log('Applying choices:', candidate.choices);
      applyChoices(count===1?'open':String(count), candidate.choices); // keep emojis!
      
      console.log('Updating answer fields...');
      ['a1','a2','a3','a4'].forEach((id,i)=> $('#'+id).value=(out.choices?.[i]||'').replace(/^(\p{Emoji_Presentation}|\p{Emoji})\s*/u,'').trim());
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast('AI generated');
      console.log('=== GENERATION COMPLETE ===');
    }catch(e){
      console.log('AI generation failed, using offline:', e);
      const out=offlineQ(count===1?4:count,subject,ls,concise);
      await setQuestionSafe(out.question, false, out.fromBank, false);
      applyChoices(count===1?'open':String(count), out.choices);
      
      // Ensure students stay in parking lot after question changes
      distribute(false);
      
      // Cue reset to ensure all students are properly positioned
      setTimeout(() => {
        $('#quickReset').click();
      }, 100);
      
      aiStatus(); toast('AI (offline)');
    }
  };

  // Info dialog functionality
  $('#inquiryAgentLogo').onclick=()=>$('#infoModal').classList.add('show');
  $('#closeInfo').onclick=()=>$('#infoModal').classList.remove('show');
  
  // roster/save/load/reset buttons
  $('#openRoster').onclick=()=>$('#rosterModal').classList.add('show');
  $('#closeRoster').onclick=()=>$('#rosterModal').classList.remove('show');
  $('#applyRoster').onclick=()=>{ roster=$('#rosterInput').value.split(/\n+/).map(s=>s.trim()).filter(Boolean); save('mxq_roster',roster); makeBadges(); awaitLayoutSpread(); $('#rosterModal').classList.remove('show'); toast('Roster applied') };
  $('#saveBtn').onclick=()=>{const layout=badges.map(b=>({name:b.textContent.trim(),left:b.style.left,top:b.style.top,zone:b.dataset.zone,hidden:b.classList.contains('pickedHidden'),ig:b.dataset.ignore==='true'})); save('mxq_layout',layout); toast('Layout saved')};
  $('#loadBtn').onclick=()=>{const layout=load('mxq_layout'); if(!layout){toast('No saved layout');return} const map=new Map(layout.map(x=>[x.name,x])); badges.forEach(b=>{const r=map.get(b.textContent.trim()); if(r){b.style.left=r.left;b.style.top=r.top;b.dataset.zone=r.zone;b.dataset.lastX=r.left;b.dataset.lastY=r.top;b.classList.toggle('pickedHidden',!!r.hidden); if(b.dataset.zone==='parking') b.classList.add('inParking'); else b.classList.remove('inParking');}}); stats(); toast('Layout loaded')};

  $('#resetWeekBtn').onclick=()=>{pickedSet.clear();save('mxq_picked',[]);badges.forEach(b=>b.classList.remove('pickedHidden')); stats(); toast('Weekly picks cleared')};
  
  // Reset questions button - clears question tracking to start fresh
  $('#resetQuestionsBtn').onclick=()=>{
    localStorage.removeItem('mxq_used_questions');
    console.log('Question tracking manually reset - all questions will be available again');
    toast('Question tracking reset - all questions available');
  };
  $('#quickReset').onclick=()=>{
    distribute(true); 
    resetT(); // Also reset timer
    toast('All to Parking & Timer Reset')};
  
  // Partner function
  $('#partnerBtn').onclick=createPartners;
  
  function changeGroupSize(delta) {
    const input = document.getElementById('partnerSize');
    const currentValue = parseInt(input.value) || 2;
    const newValue = Math.max(2, Math.min(10, currentValue + delta));
    input.value = newValue;
  }
  
  // Add P hotkey support for partner size input
  document.getElementById('partnerSize').addEventListener('keydown', function(e) {
    if(e.key.toLowerCase() === 'p') {
      e.preventDefault();
      createPartners();
    }
  });
  
  // Add event listeners for group size buttons
  document.getElementById('decreaseGroupSize').addEventListener('click', function() {
    changeGroupSize(-1);
  });
  
  document.getElementById('increaseGroupSize').addEventListener('click', function() {
    changeGroupSize(1);
  });
  
  function createPartners(){
    console.log('=== CREATE PARTNERS FUNCTION STARTED ===');
    const groupSize = parseInt($('#partnerSize').value) || 2;
    console.log('Group size:', groupSize);
    if(groupSize < 2 || groupSize > 10) {
      toast('Group size must be 2-10');
      return;
    }
    
    // Keep current question displayed - don't change it to PARTNERS
    // setQuestionSafe('PARTNERS');
    
    // Get all students (not in parking, excluding Mr. Cushman)
    const allStudents = badges.filter(b => 
      b.dataset.ignore !== 'true' && 
      !b.textContent.includes('Mr. Cushman')
    );
    console.log('All students count:', allStudents.length);
    
    // Get placed students (not in parking) - includes all students outside parking lot
    const placedStudents = allStudents.filter(b => b.dataset.zone !== 'parking' && b.dataset.zone !== undefined);
    console.log('Placed students count:', placedStudents.length);
    
    // Get students currently in parking lot
    const studentsInParking = allStudents.filter(b => b.dataset.zone === 'parking');
    console.log('Students in parking count:', studentsInParking.length);
    
    let studentsToGroup = [];
    let allInParking = false;
    
    // Check if ALL students are in parking lot
    if(studentsInParking.length === allStudents.length) {
      // All students are in parking - group them there
      allInParking = true;
      studentsToGroup = allStudents.map(b => b.textContent.trim());
      console.log('All students in parking - grouping in parking lot');
    } else {
      // Some students are outside parking - group only those outside parking
      allInParking = false;
      studentsToGroup = placedStudents.map(b => b.textContent.trim());
      console.log('Some students outside parking - grouping in response zone');
    }
    
    console.log('Students to group:', studentsToGroup);
    console.log('All in parking flag:', allInParking);
    
    // Create balanced groups (some groups can be 1 person larger if needed)
    const groups = [];
    const totalStudents = studentsToGroup.length;
    
    if(totalStudents === 0) {
      toast('No students to group');
      return;
    }
    
    // Shuffle the students randomly
    const shuffledStudents = [...studentsToGroup].sort(() => Math.random() - 0.5);
    
    // Create groups with some groups being +1 larger if needed
    const numGroups = Math.floor(totalStudents / groupSize);
    const extraStudents = totalStudents % groupSize;
    
    let studentIndex = 0;
    for(let i = 0; i < numGroups; i++) {
      const currentGroupSize = groupSize + (i < extraStudents ? 1 : 0);
      const group = shuffledStudents.slice(studentIndex, studentIndex + currentGroupSize);
      groups.push(group);
      studentIndex += currentGroupSize;
    }
    
    // Determine positioning based on whether students are in parking or response areas
    let startX, startY, badgeWidth, badgeHeight, groupSpacing;
    
    if(allInParking) {
      // All students are in parking - group them there
      console.log('Setting up parking lot positioning');
      const parkingPad = document.getElementById('parkingPad');
      const parkingRect = parkingPad.getBoundingClientRect();
      const stageRect = document.getElementById('stage').getBoundingClientRect();
      startX = parkingRect.left - stageRect.left + 20;
      startY = parkingRect.top - stageRect.top + 80; // Below the parking label
      badgeWidth = 100;
      badgeHeight = 50;
      groupSpacing = 30;
      
      // Keep students in parking lot - don't move them to response zone
      studentsToGroup.forEach(studentName => {
        const badge = allStudents.find(b => b.textContent.trim() === studentName);
        if(badge && !badge.textContent.includes('Mr. Cushman')) {
          badge.dataset.zone = 'parking';
          badge.classList.add('inParking');
        }
      });
    } else {
      // Some students are in response areas - move them to response zone
      console.log('Setting up response zone positioning');
      startX = 20;
      startY = 80;
      badgeWidth = 100;
      badgeHeight = 50;
      groupSpacing = 30;
      
      // Move only the students that should be grouped to the response zone
      studentsToGroup.forEach(studentName => {
        const badge = allStudents.find(b => b.textContent.trim() === studentName);
        if(badge && !badge.textContent.includes('Mr. Cushman')) {
          badge.dataset.zone = '0';
          badge.classList.remove('inParking');
        }
      });
    }
    
    // Ensure Mr. Cushman stays in parking lot and is visible (will position after groups are placed)
    const teacherBadge = badges.find(b => b.textContent.includes('Mr. Cushman'));
    if(teacherBadge) {
      teacherBadge.dataset.zone = 'parking';
      teacherBadge.classList.add('inParking');
      teacherBadge.dataset.ignore = 'true';
      teacherBadge.style.visibility = 'visible'; // Ensure he's visible
    }
    
    // Only create response zones if students are being moved there (not when all in parking)
    if(!allInParking) {
      // Create empty response zones (no text needed) FIRST
      const choices = ['Ask your partner what they think!'];
      const colors = ['blue'];
      buildZones(choices, colors);
    }
    
    // Force a reflow to ensure the container is rendered (only if response zones exist)
    if(!allInParking) {
      document.querySelector('.zone').offsetHeight;
    }
    
    // NOW position students in groups with touching edges - simple horizontal flow
    let currentX = startX;
    let currentY = startY;
    
    // Get the actual container dimensions
    let containerWidth;
    if(!allInParking) {
      const responseZone = document.querySelector('.zone');
      containerWidth = responseZone ? responseZone.offsetWidth - 40 : 600; // Subtract padding
    } else {
      // When all students are in parking, use parking area width
      const parkingPad = document.getElementById('parkingPad');
      containerWidth = parkingPad ? parkingPad.offsetWidth - 40 : 600;
    }
    
    groups.forEach((group, groupIndex) => {
      // Calculate actual group width by measuring badges
      let groupWidth = 0;
      const groupBadges = [];
      
      // First, get all badges for this group and measure their widths
      group.forEach((studentName, studentIndex) => {
        const badge = allStudents.find(b => b.textContent.trim() === studentName);
        if(badge) {
          groupBadges.push(badge);
          // Temporarily position to measure
          badge.style.left = '0px';
          badge.style.top = '0px';
          badge.style.visibility = 'hidden';
          badge.style.position = 'absolute';
          
          // Force a reflow to get accurate measurements
          badge.offsetHeight;
          const badgeRect = badge.getBoundingClientRect();
          groupWidth += badgeRect.width;
        }
      });
      
      // Check if this group will fit on current line
      if(currentX + groupWidth > containerWidth) {
        // Start new line
        currentX = startX;
        currentY += badgeHeight + 15;
      }
      
      // Position students in this group with touching edges
      let badgeX = currentX;
      groupBadges.forEach((badge, studentIndex) => {
        badge.style.visibility = 'visible';
        badge.style.left = badgeX + 'px';
        badge.style.top = currentY + 'px';
        
        // Get the actual width of this badge
        const badgeRect = badge.getBoundingClientRect();
        badgeX += badgeRect.width; // Next badge starts where this one ends
      });
      
      // Move to next group position (add spacing after the group)
      currentX = badgeX + groupSpacing;
    });
    
    // Now position Mr. Cushman only when all students are in parking lot
    if(teacherBadge && allInParking) {
      const parkingPad = document.getElementById('parkingPad');
      if(parkingPad) {
        const parkingRect = parkingPad.getBoundingClientRect();
        const stageRect = document.getElementById('stage').getBoundingClientRect();
        
        // When all students are in parking, position at far right of second row
        const parkingWidth = parkingPad.offsetWidth - 40; // Available width
        const teacherX = parkingRect.left - stageRect.left + parkingWidth - 150; // Moved right from 180, but not as far as original 120
        const teacherY = parkingRect.top - stageRect.top + 140; // Moved down (was 120)
        
        teacherBadge.style.left = teacherX + 'px';
        teacherBadge.style.top = teacherY + 'px';
      }
    }
    // When students are in response zones, Mr. Cushman stays in his original parking position
    
    // Save the partner setup (keep current question and choices)
    const currentChoices = load('mxq_choices') || {};
    save('mxq_choices', {
      q: currentChoices.q || $('#question').textContent,
      choices: currentChoices.choices || Array.from(document.querySelectorAll('.zone h3')).map(h => h.textContent),
      mode: currentChoices.mode || '4'
    });
    
    stats();
    
    // Show group size info
    const groupSizes = groups.map(g => g.length);
    const sizeInfo = groupSizes.length > 0 ? 
      `Created ${groups.length} groups: ${groupSizes.join(', ')} students each` : 
      'No students to group';
    toast(sizeInfo);
  }

  // presets
  $('#presetMood').onclick=()=>{
    const choices=['üòå Blue Zone','üò† Red Zone','üòë Yellow Zone','üôÇ Green Zone'];
    setQuestionSafe('What Zone are you in?');
    buildZones(choices,['blue','red','yellow','green']);
    save('mxq_choices',{q:$('#question').textContent,choices,colors:['blue','red','yellow','green'],mode:'4'});
    $('#settingsModal').classList.remove('show');
    stats();
  };
  $('#presetWeekend').onclick=()=>{
    setQuestionSafe('What was the most interesting part of your weekend?');
    const lines=[
      'Something new I did or learned',
      'Doing one of my favourite things',
      'Spending time with someone I love',
      'Something else'
    ];
    applyChoices('4',lines);
    $('#settingsModal').classList.remove('show');
  };
  $('#presetLeo').onclick=()=>{
    setQuestionSafe('ü¶Å What was your favourite part of the week? ‚ù§Ô∏è');
    const lines=[
      'Something new I did or learned',
      'Doing one of my favourite things',
      'Spending time with someone I love',
      'Something else'
    ];
    applyChoices('4',lines);
    $('#settingsModal').classList.remove('show');
  };

  async function awaitLayoutSpread(){ await raf(); await raf(); distribute(true); stats(); }
  async function boot(){
    console.log('=== BOOT FUNCTION STARTED ===');
    if (localStorage.getItem('mxq_grade') === null)   save('mxq_grade','2');
    if (localStorage.getItem('mxq_blooms') === null)  save('mxq_blooms','Evaluate');
    if (localStorage.getItem('mxq_subject') === null) save('mxq_subject','General');
    if (localStorage.getItem('mxq_ls') === null)      save('mxq_ls','General');
    if (localStorage.getItem('mxq_concise') === null) save('mxq_concise', false);

    console.log('Settings initialized');
    ensureWeek();
    roster = load('mxq_roster') || $('#rosterInput').value.split(/\n+/).map(s=>s.trim()).filter(Boolean);
    console.log('Roster loaded:', roster.length, 'students');

          const grade=load('mxq_grade',''), subject=load('mxq_subject',''), ls=load('mxq_ls',''), blooms=load('mxq_blooms',''), kw=load('mxq_keywords',''); const concise=!!load('mxq_concise',false);
    console.log('Generation params:', {grade, subject, ls, blooms, kw, concise});
    
    let out;
    try{ 
      console.log('Attempting AI generation...');
      out = await getQ(4,kw,grade,subject,ls,blooms,concise);
      console.log('AI generation successful:', out);
    } catch(e) { 
      console.log('AI generation failed, using offline:', e);
      out = offlineQ(4,subject,ls,concise); 
      console.log('Offline generation result:', out);
    }
    
    console.log('Setting question:', out.question);
    setQuestionSafe(out.question, false, out.fromBank);
    console.log('Question set');
    
    // ensure emojis on initial choices too
    const initChoices = ensureEmojis(out.choices||[]);
    console.log('Initial choices with emojis:', initChoices);
    buildZones(initChoices, initChoices.map((_,i)=>['blue','red','green','purple'][i%4]));
    save('mxq_choices',{q:$('#question').textContent,choices:initChoices,mode:'4'});

    console.log('Creating badges...');
    makeBadges();
    console.log('Badges created');
    
    await awaitLayoutSpread();
    console.log('Layout spread complete');

    let t; const ro=new ResizeObserver(()=>{clearTimeout(t); t=setTimeout(()=>{distribute(false)},60)}); ro.observe($('#parkingPad'));
    window.addEventListener('resize',()=>{clearTimeout(t); t=setTimeout(()=>{distribute(false)},120)});

    aiStatus(); updateQDebug();
    console.log('=== BOOT FUNCTION COMPLETE ===');
  }
  boot();
  
  // Immediate fallback check
  const immediateCheck = () => {
    const questionEl = document.getElementById('question');
    console.log('Immediate check - Question element:', questionEl);
    console.log('Immediate check - Question text:', questionEl?.textContent);
    if (questionEl && (questionEl.textContent === 'Loading question‚Ä¶' || !questionEl.textContent.trim())) {
      console.log('Immediate fallback: Setting default question');
      setQuestionSafe('What is one smart way you can explain your thinking today?');
      const fallbackChoices = ['ü§ù Work with a partner', 'üé≤ Ask a question', 'üìñ Explain with an example', 'üìù Other (explain)'];
      buildZones(fallbackChoices, ['blue', 'red', 'green', 'purple']);
      save('mxq_choices', {q: 'What is one smart way you can explain your thinking today?', choices: fallbackChoices, mode: '4'});
    } else {
      console.log('Immediate check - question already loaded');
    }
  };
  
  // Run immediate check after a short delay to ensure DOM is ready
  setTimeout(immediateCheck, 100);
  
  // Fallback to ensure question loads
  setTimeout(() => {
    const questionEl = document.getElementById('question');
    console.log('Fallback check - Question element:', questionEl);
    console.log('Fallback check - Question text:', questionEl?.textContent);
    if (questionEl && (questionEl.textContent === 'Loading question‚Ä¶' || !questionEl.textContent.trim())) {
      console.log('Fallback: Setting default question');
      setQuestionSafe('What is one smart way you can explain your thinking today?');
      const fallbackChoices = ['ü§ù Work with a partner', 'üé≤ Ask a question', 'üìñ Explain with an example', 'üìù Other (explain)'];
      buildZones(fallbackChoices, ['blue', 'red', 'green', 'purple']);
      save('mxq_choices', {q: 'What is one smart way you can explain your thinking today?', choices: fallbackChoices, mode: '4'});
    } else {
      console.log('Fallback not needed - question already loaded');
    }
  }, 2000);

  // ---------- TIMER ----------
  let tSeconds=60, tTicker=null, tRunning=false;
  const txt=()=>{const m=Math.floor(tSeconds/60), s=String(tSeconds%60).padStart(2,'0'); return `${m}:${s}`}
  function renderTime(){ $('#timeText').textContent=txt() }
  function chime(){ try{const c=new (window.AudioContext||window.webkitAudioContext)(); const o=c.createOscillator(), g=c.createGain(); o.type='sine'; o.frequency.value=880; g.gain.value=0.0001; g.gain.exponentialRampToValueAtTime(0.18,c.currentTime+0.02); g.gain.exponentialRampToValueAtTime(0.0001,c.currentTime+1.0); o.connect(g).connect(c.destination); o.start(); o.stop(c.currentTime+1.05); setTimeout(()=>c.close(),1200);}catch{} }
  function tick(){
    if(!tRunning) return;
    if(tSeconds>0){ tSeconds--; renderTime(); if(tSeconds===0){ chime(); $('#startPause').textContent='‚ñ∂'; tRunning=false; clearInterval(tTicker); tTicker=null; } }
  }
  function start(){ if(tRunning) return; tRunning=true; $('#startPause').textContent='‚è∏'; if(!tTicker) tTicker=setInterval(tick,1000) }
  function pause(){ tRunning=false; $('#startPause').textContent='‚ñ∂'; if(tTicker){clearInterval(tTicker); tTicker=null} }
  function toggleRun(){ tRunning?pause():start() }
  function add(sec){ tSeconds=Math.max(0,Math.min(60*60, tSeconds+sec)); renderTime(); }
  function resetT(){ 
    pause(); 
    tSeconds=60; 
    renderTime(); 
    // Also reset weekly picks when timer is reset
    pickedSet.clear();
    save('mxq_picked',[]);
    badges.forEach(b=>b.classList.remove('pickedHidden'));
    stats();
  }

  let isReading = false;
  let currentReadingTimeout = null;
  let currentHighlightTimeout = null;
  
  function readAloud(){
    console.log('readAloud function called');
    
    // If already reading, stop it
    if (isReading) {
      console.log('Stopping current reading');
      stopReading();
      return;
    }
    
    // Ensure voices are loaded
    if (window.speechSynthesis.getVoices().length === 0) {
      console.log('Voices not loaded, waiting...');
      window.speechSynthesis.onvoiceschanged = () => {
        readAloud();
      };
      return;
    }
    
    // Set reading state
    isReading = true;
    const readBtn = $('#readAloudBtn');
    readBtn.style.backgroundColor = '#22c55e';
    readBtn.style.color = 'white';
    readBtn.style.transform = 'scale(0.95)';
    readBtn.style.boxShadow = 'inset 0 2px 4px rgba(0,0,0,0.3)';
    
    // Reset button style after a short delay
    setTimeout(() => {
      readBtn.style.transform = '';
      readBtn.style.boxShadow = '';
    }, 150);
    
    const question = $('#question').textContent;
    const choices = Array.from(document.querySelectorAll('.zone h3')).map(h => h.textContent);
    
    // Try to get a Canadian or natural voice
    const voices = window.speechSynthesis.getVoices();
    const preferredVoices = voices.filter(voice => 
      voice.name.includes('Samantha') || 
      voice.name.includes('Alex') || 
      voice.name.includes('Victoria') ||
      voice.name.includes('Daniel') ||
      voice.name.includes('Karen') ||
      voice.name.includes('Tessa') ||
      voice.name.includes('Tom') ||
      voice.name.includes('Fiona') ||
      voice.name.includes('Moira') ||
      voice.name.includes('Rishi') ||
      voice.name.includes('Ava') ||
      voice.name.includes('Siri') ||
      voice.name.includes('Google') ||
      voice.name.includes('Microsoft')
    );
    
    const selectedVoice = preferredVoices.length > 0 ? preferredVoices[0] : null;
    
    // Create word mapping with element references, properly handling emojis
    const wordMap = [];
    
    // Process question words - create a clean version without emojis for speech
    const questionWords = question.split(' ');
    const questionWordsClean = [];
    const questionWordIndices = [];
    
    questionWords.forEach((word, index) => {
      // Skip if this is an emoji
      if (!/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu.test(word)) {
        questionWordsClean.push(word);
        questionWordIndices.push(index);
      }
    });
    
    // Add question words to map
    questionWordsClean.forEach((word, cleanIndex) => {
      wordMap.push({
        word: word,
        element: $('#question'),
        originalIndex: questionWordIndices[cleanIndex],
        type: 'question'
      });
    });
    
    // Process choice words
    choices.forEach((choice, choiceIndex) => {
      const choiceWords = choice.split(' ');
      const choiceWordsClean = [];
      const choiceWordIndices = [];
      
      choiceWords.forEach((word, index) => {
        // Skip if this is an emoji
        if (!/[\u{1F600}-\u{1F64F}]|[\u{1F300}-\u{1F5FF}]|[\u{1F680}-\u{1F6FF}]|[\u{1F1E0}-\u{1F1FF}]|[\u{2600}-\u{26FF}]|[\u{2700}-\u{27BF}]|[\u{1F900}-\u{1F9FF}]|[\u{1F018}-\u{1F270}]|[\u{238C}-\u{2454}]|[\u{20D0}-\u{20FF}]/gu.test(word)) {
          choiceWordsClean.push(word);
          choiceWordIndices.push(index);
        }
      });
      
      // Add choice words to map
      choiceWordsClean.forEach((word, cleanIndex) => {
        wordMap.push({
          word: word,
          element: document.querySelectorAll('.zone h3')[choiceIndex],
          originalIndex: choiceWordIndices[cleanIndex],
          type: 'choice',
          choiceIndex: choiceIndex
        });
      });
    });
    
    let currentWordIndex = 0;
    
    function speakNextWord() {
      if (!isReading || currentWordIndex >= wordMap.length) {
        // All done - clean up
        stopReading();
        return;
      }
      
      const currentWord = wordMap[currentWordIndex];
      
      // Remove previous highlighting
      document.querySelectorAll('.highlight-word').forEach(el => {
        el.classList.remove('highlight-word');
      });
      
      // Highlight current word using the original index
      const element = currentWord.element;
      const text = element.textContent;
      const words = text.split(' ');
      
      if (words[currentWord.originalIndex]) {
        // Find the position of this word in the original text
        let wordStart = 0;
        for (let i = 0; i < currentWord.originalIndex; i++) {
          wordStart += words[i].length + 1; // +1 for space
        }
        
        const beforeWord = text.substring(0, wordStart);
        const afterWord = text.substring(wordStart + words[currentWord.originalIndex].length);
        
        element.innerHTML = `${beforeWord}<span class="highlight-word" style="background-color: rgba(34, 211, 153, 0.5); border-radius: 4px; padding: 0; margin: 0; display: inline; font-size: inherit; line-height: inherit;">${words[currentWord.originalIndex]}</span>${afterWord}`;
      }
      
      // Create speech for this word
      const speech = new SpeechSynthesisUtterance(currentWord.word);
      speech.rate = 1.0; // Natural speed - not too fast or slow
      speech.pitch = 1.1;
      speech.volume = 0.9;
      if (selectedVoice) speech.voice = selectedVoice;
      
      speech.onend = () => {
        // Clear highlighting after a delay (separate from voice timing)
        setTimeout(() => {
          $('#question').innerHTML = $('#question').textContent;
          document.querySelectorAll('.zone h3').forEach(el => {
            el.innerHTML = el.textContent;
          });
        }, 400); // Highlighting stays visible for 400ms
        
        // Move to next word immediately (no delay for voice)
        currentReadingTimeout = setTimeout(() => {
          if (isReading) {
            currentWordIndex++;
            speakNextWord();
          }
        }, 50); // Very short delay for voice flow
      };
      
      window.speechSynthesis.speak(speech);
    }
    
    // Start speaking
    speakNextWord();
  }
  
  function stopReading() {
    isReading = false;
    window.speechSynthesis.cancel();
    if (currentReadingTimeout) {
      clearTimeout(currentReadingTimeout);
      currentReadingTimeout = null;
    }
    if (currentHighlightTimeout) {
      clearTimeout(currentHighlightTimeout);
      currentHighlightTimeout = null;
    }
    
    // Reset button appearance
    $('#readAloudBtn').style.backgroundColor = '';
    $('#readAloudBtn').style.color = '';
    
    // Clean up highlighting by restoring original text content
    $('#question').innerHTML = $('#question').textContent;
    document.querySelectorAll('.zone h3').forEach(el => {
      el.innerHTML = el.textContent;
    });
  }

  $('#minus30').onclick=()=>add(-30);
  $('#plus30').onclick=()=>add(+30);
  $('#startPause').onclick=toggleRun;
  $('#tReset').onclick=resetT;
  // Read button with proper click-to-start/click-to-stop behavior
  const readBtn = $('#readAloudBtn');
  if (readBtn) {
    // Simple click handler for proper click-to-start/click-to-stop behavior
    readBtn.onclick = readAloud;
    
    console.log('Read button configured for click-to-start/click-to-stop behavior');
  }
  renderTime();

  function switchModel(model) {
    $('#aiModel').value = model;
    save('mxq_ai_model', model);
    // Clear cached AI status to force fresh connection test
    localStorage.removeItem('mxq_ai_status');
    toast(`Switched to ${model}`);
    // Clear any existing warnings when switching models
    updateAIWarning('', false);
    // Update status to show we're trying a new model
    aiStatus();
  }
  
  function openAISettings() {
    // Open settings modal first
    $('#settingsModal').classList.add('show');
    // Then open AI settings modal on top
    const savedKey = load('mxq_ai_key');
    $('#aiKey').value = savedKey || 'AIzaSyDpx9ITK7RRlxYgbVaF_gkDJAAdmkjBzoQ'; 
    $('#aiModel').value = load('mxq_ai_model') || 'gemini-2.0-flash'; 
    $('#aiModal').classList.add('show'); 
    aiStatus();
  }
  
  // Make function globally accessible
  window.openAISettings = openAISettings;

  $('#model2Flash').onclick=()=>switchModel('gemini-2.0-flash');
  $('#model1Flash').onclick=()=>switchModel('gemini-1.5-flash');
  $('#model1Pro').onclick=()=>switchModel('gemini-1.5-pro');

  function checkRateLimitStatus() {
    console.log('=== RATE LIMIT STATUS CHECK ===');
    const models = ['gemini-2.0-flash', 'gemini-1.5-flash', 'gemini-1.5-pro'];
    const currentModel = load('mxq_ai_model') || 'gemini-2.0-flash';
    console.log('Current model:', currentModel);
    console.log('Available models:', models);
    
    // Check if we have any cached error status
    const lastError = localStorage.getItem('mxq_last_ai_error');
    if (lastError) {
      console.log('Last AI error:', lastError);
    }
    
    // Check if we have any successful status
    const aiStatus = load('mxq_ai_status');
    if (aiStatus) {
      console.log('Last AI status:', aiStatus);
    }
    
    return {
      currentModel,
      availableModels: models,
      lastError,
      aiStatus
    };
  }
  
  // Make it globally accessible
  window.checkRateLimitStatus = checkRateLimitStatus;

})();
</script>
</body>
</html>